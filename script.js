// Asegurarse de que este script se ejecute después de que el HTML se parsea (usar 'defer' en HTML)
console.log(">>>> Watertoy Arcade - script.js execution started.");

// --- DEFINICIÓN DE LA FUNCIÓN PRINCIPAL ---
function initializeAndRunGame() {
    console.log(">>>> initializeAndRunGame() called. Document readyState:", document.readyState);

    const canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error("!!!!!!!! FATAL ERROR: Canvas element with id 'gameCanvas' NOT FOUND !!!!!!!");
        const body = document.querySelector('body');
        if (body) body.innerHTML = '<h1 style="color:red; text-align:center; margin-top: 50px;">Error: No se pudo cargar el juego (Canvas no encontrado).</h1>';
        return; 
    }
    console.log(">>>> Canvas found:", canvas);
    const ctx = canvas.getContext('2d');

    const messageBoard = document.getElementById('messageBoard');
    const leftJetButton = document.getElementById('leftJetButton');
    const rightJetButton = document.getElementById('rightJetButton');
    const tiltLeftButton = document.getElementById('tiltLeftButton');
    const tiltRightButton = document.getElementById('tiltRightButton');
    const resetButton = document.getElementById('resetButton');
    const enableSensorButton = document.getElementById('enableSensorButton');
    const fullscreenButton = document.getElementById('fullscreenButton'); 
    const startScreen = document.getElementById('startScreen');
    const startNormalModeButton = document.getElementById('startNormalModeButton');
    const startArcadeModeButton = document.getElementById('startArcadeModeButton'); 
    const howToPlayButton = document.getElementById('howToPlayButton');
    const howToPlayScreen = document.getElementById('howToPlayScreen'); 
    const closeHowToPlayButton = document.getElementById('closeHowToPlayButton'); 
    const levelStartScreen = document.getElementById('levelStartScreen');
    const levelStartTitle = document.getElementById('levelStartTitle');
    const levelStartObjective = document.getElementById('levelStartObjective');
    const beginLevelButton = document.getElementById('beginLevelButton');
    const levelEndScreen = document.getElementById('levelEndScreen');
    const levelEndTitle = document.getElementById('levelEndTitle');
    const levelEndTimeBonus = document.getElementById('levelEndTimeBonus');
    const levelEndTotalScore = document.getElementById('levelEndTotalScore');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const arcadeEndToMenuButton = document.getElementById('arcadeEndToMenuButton');
    
    console.log(">>>> Primary DOM elements obtained.");

    const gameScreenWidth = 450;
    const gameScreenHeight = 400;
    canvas.width = gameScreenWidth;
    canvas.height = gameScreenHeight;

    const RING_OUTER_RADIUS = 18; const RING_VISUAL_THICKNESS = 6; const MAX_RINGS_PER_PEG = 6; const RING_COLORS = ['#FF4136', '#0074D9', '#2ECC40', '#FFDC00']; const TOTAL_COLORS = RING_COLORS.length; const GRAVITY_BASE = 0.038; const MAX_JET_PRESSURE = 1.0; const JET_PRESSURE_INCREMENT_BASE = 0.05; const JET_PRESSURE_DECREMENT_BASE = 0.08; const BASE_JET_STRENGTH = 3.8; const JET_HORIZONTAL_INFLUENCE_RATIO = 0.28; const JET_EFFECT_RADIUS_Y = gameScreenHeight * 0.75; const JET_EFFECT_RADIUS_X = gameScreenWidth * 0.38; const JET_VERTICAL_FALLOFF_POWER = 0.6; const MAX_JET_PARTICLES = 200; const TILT_FORCE_BUTTON_BASE = 0.30; const TILT_FORCE_SENSOR_MULTIPLIER = 0.055; const MAX_SENSOR_TILT_FORCE = 0.55; const WATER_FRICTION_COEFF = 0.028; const BOUNCE_FACTOR = -0.2; const RING_COLLISION_BOUNCE = 0.5; const PEG_COLLISION_BOUNCE_FACTOR = -0.3; const PEG_STROKE_COLOR = '#505050'; const PEG_FILL_COLOR = '#808080'; const PEG_VISUAL_WIDTH = 10; const PEG_MOVEMENT_SPEED_X = 0.7; const PEG_MOVEMENT_SPEED_Y_MIN = 0.3; const PEG_MOVEMENT_SPEED_Y_MAX = 0.8;const RING_OUTLINE_COLOR = 'rgba(0,0,0,0.85)'; const RING_OUTLINE_WIDTH_ON_SCREEN = 1.0; const FLAT_RING_VIEW_THICKNESS = 7; const GROUND_FLAT_RING_THICKNESS = 5; const MAX_TOTAL_RINGS_ON_SCREEN = MAX_RINGS_PER_PEG * TOTAL_COLORS;
    let score = 0; let scorePulseActive = false; let scorePulseTimer = 0; const SCORE_PULSE_DURATION = 12; let rings = []; let pegs = []; let lastTime = 0; const TARGET_FPS = 60; const TARGET_DT = 1 / TARGET_FPS; let floatingScores = []; let jetParticles = []; let gameLoopId = null; let gameRunning = false; let isPausedForLevelTransition = false; let landedRingsCount = 0; let gameOver = false; let baseScoreFromRings = 0; let bonusScoreFromColorStreak = 0; let bonusScoreFromFullPegsGeneral = 0; let bonusScoreFromMonoColorPegsSpecific = 0; let allPegsCompletedBonusFactor = 1; let masterBonusFactor = 1; let currentScoreDisplaySize = 22; const SCORE_NORMAL_SIZE = 22; const SCORE_PULSE_SIZE = 26;
    let currentGameMode = 'none'; let currentArcadeLevel = 0; let timeLeftInLevel = 0; 
    const ARCADE_LEVEL_TIME_LIMIT = 90; 
    const ARCADE_LEVELS = [ { name: "Nivel 1: Clásico", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 2, pegConfigKey: 'standard' }, { name: "Nivel 2: Línea Central", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 3, pegConfigKey: 'centerLine' }, { name: "Nivel 3: Invertido", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 4, pegConfigKey: 'invertedStandard' }, { name: "Nivel 4: Movedizos Horizontales", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 5, pegConfigKey: 'horizontalMovers' }, { name: "Nivel 5: Bailarines Verticales", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 6, pegConfigKey: 'verticalMovers' } ];
    let leftJetInputActive = false; let rightJetInputActive = false; let leftJetPressure = 0; let rightJetPressure = 0; let tiltLeftActive = false; let tiltRightActive = false; let sensorTiltX = 0; let sensorAvailable = false; let sensorActive = false;
    const KEY_LEFT_ARROW = 'ArrowLeft'; const KEY_RIGHT_ARROW = 'ArrowRight'; const KEY_JET_LEFT = 'KeyA'; const KEY_JET_RIGHT = 'KeyD';

    function createRing(x, y, color) { let speedMagnitude = 0.08 + Math.random() * 0.12; return { x: x, y: y, vx: (Math.random() - 0.5) * 0.4, vy: (Math.random() - 0.5) * 0.4, color: color, originalColor: color, landed: false, pegIndex: -1, landedOrder: -1, basePoints: 25, awardedPoints: 0, rotationAngle: Math.random() * Math.PI * 2, initialRotationSpeed: (Math.random() < 0.5 ? -1 : 1) * speedMagnitude, rotationSpeed: 0, zRotationAngle: (Math.random() - 0.5) * 0.3, zRotationSpeed: (Math.random() - 0.5) * 0.03, isFlat: false, isSlidingOnPeg: false, finalYonPeg: 0 }; }
    function configurePegsForLayout(layoutType) { pegs = []; let pegData = []; const standardPegPositions = [ { xFactor: 0.22, heightFactor: 0.35, yOffsetFactor: 0 }, { xFactor: 0.78, heightFactor: 0.35, yOffsetFactor: 0 }, { xFactor: 0.38, heightFactor: 0.30, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, { xFactor: 0.62, heightFactor: 0.30, yOffsetFactor: 0.35 + (45 / gameScreenHeight) } ]; switch (layoutType) { case 'centerLine': const centerSpacing = gameScreenWidth / 5; pegData = [ { x: centerSpacing * 1, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 2, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 3, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 4, yBaseFactor: 0.3, heightFactor: 0.30 }, ]; pegData.forEach((data, index) => { pegs.push({ id: index, x: data.x, bottomY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: data.x, maxX: data.x, minY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor) }); }); break; case 'invertedStandard': pegData = [ { xFactor: 0.38, heightFactor: 0.30, yOffsetFactor: 0 }, { xFactor: 0.62, heightFactor: 0.30, yOffsetFactor: 0 }, { xFactor: 0.22, heightFactor: 0.35, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, { xFactor: 0.78, heightFactor: 0.35, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, ]; pegData.forEach((data, index) => { pegs.push({ id: index, x: gameScreenWidth * data.xFactor, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: gameScreenWidth * data.xFactor, maxX: gameScreenWidth * data.xFactor, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break; case 'horizontalMovers': const moverMarginX = gameScreenWidth * 0.1; const moverCenterGap = gameScreenWidth * 0.05; standardPegPositions.forEach((data, index) => { const pegX = gameScreenWidth * data.xFactor; let minX, maxX; if (index === 0 || index === 2) { minX = moverMarginX; maxX = gameScreenWidth / 2 - PEG_VISUAL_WIDTH - moverCenterGap / 2; } else { minX = gameScreenWidth / 2 + moverCenterGap / 2; maxX = gameScreenWidth - moverMarginX - PEG_VISUAL_WIDTH; } pegs.push({ id: index, x: (index === 0 || index === 2) ? minX : maxX, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: PEG_MOVEMENT_SPEED_X * ((index === 0 || index === 2) ? 1 : -1), vy: 0, dirX: ((index === 0 || index === 2) ? 1 : -1), dirY: 1, minX: minX, maxX: maxX, originalX: pegX, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break; case 'verticalMovers': const centerBaseX = gameScreenWidth / 2; const topBoundary = gameScreenHeight * 0.2; const bottomBoundary = gameScreenHeight * 0.8; [ { xOffset: -PEG_VISUAL_WIDTH * 1.5, initialYFactor: 0.3 }, { xOffset: -PEG_VISUAL_WIDTH * 0.5, initialYFactor: 0.5 }, { xOffset: PEG_VISUAL_WIDTH * 0.5, initialYFactor: 0.4 }, { xOffset: PEG_VISUAL_WIDTH * 1.5, initialYFactor: 0.6 }, ].forEach((data, index) => { const pegHeight = gameScreenHeight * 0.25; const initialBottomY = gameScreenHeight * data.initialYFactor + pegHeight; pegs.push({ id: index, x: centerBaseX + data.xOffset, bottomY: initialBottomY, height: pegHeight, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: (Math.random() < 0.5 ? -1 : 1) * (PEG_MOVEMENT_SPEED_Y_MIN + Math.random() * (PEG_MOVEMENT_SPEED_Y_MAX - PEG_MOVEMENT_SPEED_Y_MIN)), dirX: 1, dirY: (Math.random() < 0.5 ? -1 : 1), minX: centerBaseX + data.xOffset, maxX: centerBaseX + data.xOffset, minY: topBoundary, maxY: bottomBoundary }); }); break; case 'standard': default: standardPegPositions.forEach((data, index) => { pegs.push({ id: index, x: gameScreenWidth * data.xFactor, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: gameScreenWidth * data.xFactor, maxX: gameScreenWidth * data.xFactor, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break;} }
    function updatePegs(dt) { if (currentGameMode !== 'arcade' || currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length || !pegs) return; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if (!levelConfig) return; const configKey = levelConfig.pegConfigKey; const timeFactor = dt * TARGET_FPS * 0.5; if (configKey === 'horizontalMovers') { pegs.forEach(peg => { const prevX = peg.x; peg.x += peg.vx * timeFactor; if (peg.x + PEG_VISUAL_WIDTH/2 > peg.maxX) { peg.x = peg.maxX - PEG_VISUAL_WIDTH/2; peg.vx *= -1; } else if (peg.x - PEG_VISUAL_WIDTH/2 < peg.minX) { peg.x = peg.minX + PEG_VISUAL_WIDTH/2; peg.vx *= -1; } const deltaX = peg.x - prevX; peg.landedRings.forEach(ring => ring.x += deltaX); }); } else if (configKey === 'verticalMovers') { pegs.forEach(peg => { const prevBottomY = peg.bottomY; let newBottomY = peg.bottomY + peg.vy * timeFactor; let newTopY = newBottomY - peg.height; if (newTopY < peg.minY) { newBottomY = peg.minY + peg.height; peg.vy *= -1; } else if (newBottomY > peg.maxY ) { newBottomY = peg.maxY; peg.vy *= -1; } peg.bottomY = newBottomY; const deltaY = peg.bottomY - prevBottomY; peg.landedRings.forEach(ring => ring.y += deltaY); }); } }
    function initGame(mode) { console.log(">>>> initGame llamada con modo:", mode); currentGameMode = mode; score = 0; baseScoreFromRings = 0; bonusScoreFromColorStreak = 0; bonusScoreFromFullPegsGeneral = 0; bonusScoreFromMonoColorPegsSpecific = 0; allPegsCompletedBonusFactor = 1; masterBonusFactor = 1; scorePulseActive = false; scorePulseTimer = 0; currentScoreDisplaySize = SCORE_NORMAL_SIZE; leftJetPressure = 0; rightJetPressure = 0; tiltLeftActive = false; tiltRightActive = false; floatingScores = []; jetParticles = []; landedRingsCount = 0; gameOver = false; isPausedForLevelTransition = false; hideEndGameScreen(); if (levelStartScreen) levelStartScreen.style.display = 'none'; if (levelEndScreen) levelEndScreen.style.display = 'none'; if (startScreen) startScreen.style.display = 'none'; if (howToPlayScreen && howToPlayScreen.style.display !== 'none') howToPlayScreen.style.display = 'none'; if(messageBoard) setPersistentInstructions(); rings = []; if (currentGameMode === 'arcade') { currentArcadeLevel = 0; arcadeLevelScore = 0; score = 0; /* prepareArcadeLevel es llamado por startGameFlow */ } else { configurePegsForLayout('standard'); currentArcadeLevel = -1; timeLeftInLevel = -1; const initialRingCount = MAX_TOTAL_RINGS_ON_SCREEN; const colorsToDistribute = [...RING_COLORS]; let colorCounter = 0; for (let i = 0; i < initialRingCount; i++) { const color = colorsToDistribute[colorCounter % TOTAL_COLORS]; colorCounter++; const x = RING_OUTER_RADIUS + Math.random() * (gameScreenWidth - 2 * RING_OUTER_RADIUS); const y = gameScreenHeight * 0.60 + Math.random() * (gameScreenHeight * 0.40 - RING_OUTER_RADIUS); rings.push(createRing(x, y, color)); } } if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } console.log(">>>> initGame finalizada para modo:", mode); }
    function prepareArcadeLevel(levelIndex) { if (levelIndex < 0 || levelIndex >= ARCADE_LEVELS.length) { console.error("Índice de nivel arcade inválido:", levelIndex); triggerGameOver_ArcadeMode(currentArcadeLevel >= ARCADE_LEVELS.length); return; } console.log(">>>> prepareArcadeLevel llamada para nivel:", levelIndex + 1); isPausedForLevelTransition = true; gameRunning = false; if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null;} currentArcadeLevel = levelIndex; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; const currentLevelStartTitle = document.getElementById('levelStartTitle'); const currentLevelStartObjective = document.getElementById('levelStartObjective'); const currentLevelStartScreen = document.getElementById('levelStartScreen'); if (currentLevelStartTitle) currentLevelStartTitle.textContent = levelConfig.name || `Nivel ${levelIndex + 1}`; let objectiveText = "Objetivo: "; if (levelConfig.ringsObjective.type === 'fillPegs') { objectiveText += `Llenar ${levelConfig.ringsObjective.count} palos`; } if (levelConfig.OR_ringsObjective) { objectiveText += " O "; if (levelConfig.OR_ringsObjective.type === 'minPerPeg') { objectiveText += `Poner ${levelConfig.OR_ringsObjective.count} aros en cada palo.`; } } if (currentLevelStartObjective) currentLevelStartObjective.textContent = objectiveText; const currentLevelEndScreen = document.getElementById('levelEndScreen'); if(currentLevelEndScreen) currentLevelEndScreen.style.display = 'none'; if (currentLevelStartScreen) currentLevelStartScreen.style.display = 'flex'; if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } if(!gameLoopId) gameLoopId = requestAnimationFrame(gameLoop); }
    function startPreparedArcadeLevel() { console.log(">>>> startPreparedArcadeLevel llamada para nivel:", currentArcadeLevel + 1); const currentLevelStartScreen = document.getElementById('levelStartScreen'); isPausedForLevelTransition = false; if(currentLevelStartScreen) currentLevelStartScreen.style.display = 'none'; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if (!levelConfig) { console.error("startPreparedArcadeLevel: No se encontró config para nivel", currentArcadeLevel); return;} configurePegsForLayout(levelConfig.pegConfigKey); timeLeftInLevel = levelConfig.timeLimit; rings = []; landedRingsCount = 0; if (pegs) { pegs.forEach(p => { p.landedRings = []; p.isFullAndScored = false; p.isMonoColor = false; });} else { console.error("startPreparedArcadeLevel: pegs NO definidos"); return;} const initialRingCount = MAX_TOTAL_RINGS_ON_SCREEN; const colorsToDistribute = [...RING_COLORS]; let colorCounter = 0; for (let i = 0; i < initialRingCount; i++) { const color = colorsToDistribute[colorCounter % TOTAL_COLORS]; colorCounter++; const x = RING_OUTER_RADIUS + Math.random() * (gameScreenWidth - 2 * RING_OUTER_RADIUS); const y = gameScreenHeight * 0.60 + Math.random() * (gameScreenHeight * 0.40 - RING_OUTER_RADIUS); rings.push(createRing(x, y, color)); } gameRunning = true; gameOver = false; if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null; if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } gameLoopId = requestAnimationFrame(gameLoop); }
    function drawRing(ring) { ctx.save(); ctx.translate(ring.x, ring.y); if ((!ring.isFlat || ring.landed) && !ring.isSlidingOnPeg) { ctx.rotate(ring.zRotationAngle); } const outerRadius = RING_OUTER_RADIUS; const innerRadiusMaterial = RING_OUTER_RADIUS - RING_VISUAL_THICKNESS; if (ring.isFlat) { const currentFlatThickness = ring.landed ? FLAT_RING_VIEW_THICKNESS : GROUND_FLAT_RING_THICKNESS; const halfFlatViewThickness = currentFlatThickness / 2; const flatDrawWidth = outerRadius * 2; ctx.fillStyle = RING_OUTLINE_COLOR; ctx.fillRect( -flatDrawWidth / 2 - RING_OUTLINE_WIDTH_ON_SCREEN, -halfFlatViewThickness - RING_OUTLINE_WIDTH_ON_SCREEN, flatDrawWidth + (RING_OUTLINE_WIDTH_ON_SCREEN * 2), currentFlatThickness + (RING_OUTLINE_WIDTH_ON_SCREEN * 2) ); ctx.fillStyle = ring.color; ctx.fillRect( -flatDrawWidth / 2, -halfFlatViewThickness, flatDrawWidth, currentFlatThickness ); } else { const scaleYValue = Math.abs(Math.cos(ring.rotationAngle)); const effectiveScaleY = Math.max(0.08, scaleYValue); if (scaleYValue < 0.08 && !ring.landed) { const tempFlatThickness = GROUND_FLAT_RING_THICKNESS * 0.8; const halfFlatViewThickness = tempFlatThickness / 2; const flatDrawWidth = outerRadius * 2; ctx.fillStyle = RING_OUTLINE_COLOR; ctx.fillRect( -flatDrawWidth / 2 - RING_OUTLINE_WIDTH_ON_SCREEN, -halfFlatViewThickness - RING_OUTLINE_WIDTH_ON_SCREEN, flatDrawWidth + (RING_OUTLINE_WIDTH_ON_SCREEN * 2), tempFlatThickness + (RING_OUTLINE_WIDTH_ON_SCREEN * 2) ); ctx.fillStyle = ring.color; ctx.fillRect( -flatDrawWidth / 2, -halfFlatViewThickness, flatDrawWidth, tempFlatThickness ); } else { ctx.scale(1, effectiveScaleY); const outlineScaledOffset = RING_OUTLINE_WIDTH_ON_SCREEN / effectiveScaleY; ctx.beginPath(); ctx.arc(0, 0, outerRadius + outlineScaledOffset, 0, Math.PI * 2, false); ctx.arc(0, 0, Math.max(0, innerRadiusMaterial - outlineScaledOffset), 0, Math.PI * 2, true); ctx.fillStyle = RING_OUTLINE_COLOR; ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, outerRadius, 0, Math.PI * 2, false); ctx.arc(0, 0, innerRadiusMaterial, 0, Math.PI * 2, true);    ctx.fillStyle = ring.color; ctx.fill(); } } ctx.restore(); }
    function drawAllPegsAndLandedRings() { if(!pegs) return; pegs.forEach(peg => { ctx.fillStyle = PEG_FILL_COLOR; ctx.strokeStyle = PEG_STROKE_COLOR; ctx.lineWidth = 2; const pegTopY = peg.bottomY - peg.height; ctx.beginPath(); ctx.roundRect(peg.x - PEG_VISUAL_WIDTH / 2, pegTopY, PEG_VISUAL_WIDTH, peg.height, [PEG_VISUAL_WIDTH/3, PEG_VISUAL_WIDTH/3, 0, 0]); ctx.fill(); ctx.stroke(); peg.landedRings.forEach(drawRing); }); }
    function drawArcadeInfoOnCanvas() { if (currentGameMode !== 'arcade' || !gameRunning || gameOver || currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length) return; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if(!levelConfig) return; ctx.save(); ctx.font = 'bold 18px Arial'; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; ctx.shadowBlur = 2; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1; ctx.fillText(`Nivel: ${currentArcadeLevel + 1}`, 10, 10); const minutes = Math.floor(timeLeftInLevel / 60); const seconds = Math.floor(timeLeftInLevel % 60); ctx.fillText(`Tiempo: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`, 10, 35); let currentTotalLandedRingsInPegs = 0; if(pegs) pegs.forEach(p => currentTotalLandedRingsInPegs += p.landedRings.length); let objectiveDisplay = ""; if(levelConfig.ringsObjective.type === 'fillPegs'){ objectiveDisplay = `Llenar ${levelConfig.ringsObjective.count} palos`; } if(levelConfig.OR_ringsObjective && levelConfig.OR_ringsObjective.type === 'minPerPeg'){ objectiveDisplay += (objectiveDisplay ? " O " : "") + `${levelConfig.OR_ringsObjective.count} aros/palo`; } ctx.fillText(`Obj: ${objectiveDisplay} (${currentTotalLandedRingsInPegs} enc.)`, 10, 60); ctx.restore(); }
    function drawScoreOnCanvas() { if (startScreen && startScreen.style.display === 'flex' && !gameRunning) return; if (gameOver && currentGameMode === 'arcade' && (currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length )) return; ctx.save(); ctx.font = `bold ${currentScoreDisplaySize}px Arial`; ctx.textAlign = 'right'; ctx.textBaseline = 'top'; ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; ctx.shadowBlur = 3; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1; if (scorePulseActive) { ctx.fillStyle = '#FFD700'; } else { ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; } ctx.fillText(`Score: ${score}`, gameScreenWidth - 10, 10); ctx.restore(); }
    instructionTimeout = null; function showMessage(text, duration = 3000, isInstruction = false) { if (instructionTimeout && !isInstruction) { clearTimeout(instructionTimeout); } if(messageBoard) {messageBoard.textContent = text; messageBoard.style.opacity = 1;} if (!isInstruction) { instructionTimeout = setTimeout(() => { if(messageBoard) messageBoard.style.opacity = 0; instructionTimeout = null; setTimeout(setPersistentInstructions, 700); }, duration); } }
    function setPersistentInstructions() { /* ... (código sin cambios, con verificaciones de messageBoard) ... */ }
    function updateScore(pointsToAdd, message = "") { if (pointsToAdd > 0) { score += pointsToAdd; scorePulseActive = true; scorePulseTimer = SCORE_PULSE_DURATION; currentScoreDisplaySize = SCORE_PULSE_SIZE; } else if (pointsToAdd < 0) { score += pointsToAdd; } if (message && message !== "") { showMessage(message, 2500); } }
    function checkArcadeLevelWinCondition() { if (currentGameMode !== 'arcade' || currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length || !pegs) return false; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; let fullPegsCount = 0; pegs.forEach(peg => { if (peg.landedRings.length >= MAX_RINGS_PER_PEG) { fullPegsCount++; } }); if (levelConfig.ringsObjective.type === 'fillPegs' && fullPegsCount >= levelConfig.ringsObjective.count) { return true; } if (levelConfig.OR_ringsObjective && levelConfig.OR_ringsObjective.type === 'minPerPeg') { const minRings = levelConfig.OR_ringsObjective.count; let allPegsMeetMin = true; for (const peg of pegs) { if (peg.landedRings.length < minRings) { allPegsMeetMin = false; break; } } if (allPegsMeetMin) return true; } return false; }
    function checkAndApplyBonuses(landedRing, peg) { let pointsForThisSpecificRing = landedRing.basePoints; let bonusMessageText = ""; baseScoreFromRings += landedRing.basePoints; if ('vibrate' in navigator) { navigator.vibrate(75); } let mightBecomeMonoColor = true; if(peg.landedRings.length === MAX_RINGS_PER_PEG) { const firstColorInPeg = peg.landedRings[0].color; for(const r of peg.landedRings) { if (r.color !== firstColorInPeg) { mightBecomeMonoColor = false; break; } } } else { mightBecomeMonoColor = false; } if (peg.landedRings.length > 1 && !mightBecomeMonoColor && landedRing.landedOrder > 0 ) { const previousRingInStack = peg.landedRings[landedRing.landedOrder -1]; if (previousRingInStack && previousRingInStack.color === landedRing.color) { let colorStreakBonus = landedRing.basePoints; pointsForThisSpecificRing += colorStreakBonus; bonusScoreFromColorStreak += colorStreakBonus; bonusMessageText += ` Color x2!`;} } landedRing.awardedPoints = pointsForThisSpecificRing; createFloatingScore(landedRing.x, landedRing.finalYonPeg - RING_OUTER_RADIUS, `+${pointsForThisSpecificRing}${bonusMessageText}`, landedRing.color); updateScore(pointsForThisSpecificRing); if (currentGameMode === 'normal') { landedRingsCount++; } if (peg.landedRings.length === MAX_RINGS_PER_PEG && !peg.isFullAndScored) { peg.isFullAndScored = true; let isCurrentPegMonoColor = true; const firstLandedColor = peg.landedRings[0].color; for (let k = 1; k < MAX_RINGS_PER_PEG; k++) { if (peg.landedRings[k].color !== firstLandedColor) { isCurrentPegMonoColor = false; break; } } let additionalBonusScore = 0; let pegCompletionMessage = ""; if (isCurrentPegMonoColor) { peg.isMonoColor = true; peg.monoColorValue = firstLandedColor; let currentPegAwardedPointsSum = 0; peg.landedRings.forEach(r => currentPegAwardedPointsSum += r.awardedPoints); let targetMonoScore = (landedRing.basePoints * MAX_RINGS_PER_PEG) * 10; additionalBonusScore = targetMonoScore - currentPegAwardedPointsSum; if(additionalBonusScore < 0) additionalBonusScore = 0; bonusScoreFromMonoColorPegsSpecific += additionalBonusScore; pegCompletionMessage = `PALO MONOCOLOR! (x10)`; } else { let pegTotalAwardedPoints = 0; peg.landedRings.forEach(r => { pegTotalAwardedPoints += r.awardedPoints; }); additionalBonusScore = pegTotalAwardedPoints * 3; bonusScoreFromFullPegsGeneral += additionalBonusScore; pegCompletionMessage = `PALO LLENO! (x4)`; } if(additionalBonusScore > 0) updateScore(additionalBonusScore, pegCompletionMessage); if (currentGameMode === 'normal') checkAllPegsCompleted_NormalMode(); } if (currentGameMode === 'arcade' && !gameOver) { if (checkArcadeLevelWinCondition()) { goToNextArcadeLevel(); } } }
    function checkAllPegsCompleted_NormalMode() { if (currentGameMode !== 'normal') return; if (allPegsCompletedBonusFactor > 1 && masterBonusFactor > 1) return; if(!pegs) return; const allPegsNowFull = pegs.every(p => p.isFullAndScored); if (allPegsNowFull && allPegsCompletedBonusFactor === 1) { allPegsCompletedBonusFactor = 2; showMessage("TODOS LOS PALOS LLENOS! Puntos x2!", 3500, true); let monoColorPegCount = 0; const usedColorsForMaster = new Set(); pegs.forEach(p => { if (p.isMonoColor) { monoColorPegCount++; usedColorsForMaster.add(p.monoColorValue); } }); if (monoColorPegCount === TOTAL_COLORS && usedColorsForMaster.size === TOTAL_COLORS) { masterBonusFactor = 100; showMessage("¡¡BONO MAESTRO!! Puntuación Final x100!", 5000, true); } triggerGameOver_NormalMode(); } }
    function goToNextArcadeLevel() { /* ... (Como antes, con las verificaciones de null para elementos del DOM) ... */ }
    function triggerGameOver_NormalMode() { /* ... */ } function triggerGameOver_ArcadeMode(allLevelsCompleted = false) { /* ... */ }
    function showEndGameScreen(mode, arcadeWon = false, levelReachedIfLost = 0) { /* ... */ }
    function hideEndGameScreen() { /* ... */ } function hexToRgb(hex) { /* ... */ } function createFloatingScore(x, y, text, color = "#FFFFFF", durationFrames = 90, upwardSpeed = 0.8) { /* ... */ } function updateAndDrawFloatingScores(dt) { /* ... */ } function createJetParticle(xSide, strength) { /* ... */ } function updateAndDrawJetParticles(dt) { /* ... */ } function updateRings(actualTiltForceToApply, dt) { /* ... */ }
    function handleOrientation(event) { /* ... */ } function requestSensorPermission() { /* ... */ }

    // (Aquí irían las definiciones COMPLETAS de todas las funciones auxiliares y de lógica)
    // (Como drawRing, checkAndApplyBonuses, etc.)

    // --- GAME LOOP --- (Como en la última respuesta, con la corrección del log del sensor)
    function gameLoop(currentTime) {
        if (isPausedForLevelTransition) { 
            // Dibuja la pantalla de transición si está visible
            const currentLevelStartScreen = document.getElementById('levelStartScreen');
            const currentLevelEndScreen = document.getElementById('levelEndScreen');
            if ((currentLevelStartScreen && currentLevelStartScreen.style.display === 'flex') || (currentLevelEndScreen && currentLevelEndScreen.style.display === 'flex')) {
                 if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
                 drawScoreOnCanvas(); 
                 if(currentGameMode === 'arcade' && currentArcadeLevel >= 0 && currentArcadeLevel < ARCADE_LEVELS.length && ARCADE_LEVELS[currentArcadeLevel] && currentLevelStartScreen && currentLevelStartScreen.style.display === 'flex') { 
                    drawArcadeInfoOnCanvas(); 
                }
            }
            // No cancelar el loop si está en transición, el botón lo reiniciará/continuará
            if (!gameLoopId && isPausedForLevelTransition) gameLoopId = requestAnimationFrame(gameLoop); // Si se detuvo, reiniciarlo para UI
            else if (isPausedForLevelTransition) requestAnimationFrame(gameLoop); // Mantenerlo
            return;
        }
        if (!gameRunning && !gameOver) { /* ... (Como antes) ... */ return; }
        if (gameOver) { return; }
        // ... (Resto del gameLoop como en la última versión funcional) ...
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now(); let dt = (now - lastTime) / 1000.0; if (dt <= 0 || isNaN(dt) || dt > (TARGET_DT * 5) ) dt = TARGET_DT; lastTime = now; const deltaTime = dt; if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); if (scorePulseActive) { scorePulseTimer -= deltaTime * TARGET_FPS; if (scorePulseTimer <= 0) { scorePulseActive = false; currentScoreDisplaySize = SCORE_NORMAL_SIZE; } else { const pulseProgress = 1 - (scorePulseTimer / SCORE_PULSE_DURATION); currentScoreDisplaySize = SCORE_NORMAL_SIZE + Math.sin(pulseProgress * Math.PI) * (SCORE_PULSE_SIZE - SCORE_NORMAL_SIZE); } } const accelerationFactor = deltaTime * TARGET_FPS; const pressureChange = JET_PRESSURE_INCREMENT_BASE * accelerationFactor; const pressureDecay = JET_PRESSURE_DECREMENT_BASE * accelerationFactor; if (leftJetInputActive) { leftJetPressure += pressureChange; if (leftJetPressure > MAX_JET_PRESSURE) leftJetPressure = MAX_JET_PRESSURE; if(leftJetPressure > 0.1) createJetParticle(-1, leftJetPressure); } else { leftJetPressure -= pressureDecay; if (leftJetPressure < 0) leftJetPressure = 0; } if (rightJetInputActive) { rightJetPressure += pressureChange; if (rightJetPressure > MAX_JET_PRESSURE) rightJetPressure = MAX_JET_PRESSURE; if(rightJetPressure > 0.1) createJetParticle(1, rightJetPressure); } else { rightJetPressure -= pressureDecay; if (rightJetPressure < 0) rightJetPressure = 0; } if (currentGameMode === 'arcade' && !gameOver && gameRunning) { timeLeftInLevel -= deltaTime; if (timeLeftInLevel <= 0) { timeLeftInLevel = 0; triggerGameOver_ArcadeMode(false); } } if (pegs && pegs.length > 0 && ARCADE_LEVELS[currentArcadeLevel] && (ARCADE_LEVELS[currentArcadeLevel].pegConfigKey === 'horizontalMovers' || ARCADE_LEVELS[currentArcadeLevel].pegConfigKey === 'verticalMovers')) { updatePegs(deltaTime); }  let forceForTiltUpdate = 0; if (sensorActive && sensorAvailable) { forceForTiltUpdate = sensorTiltX * TILT_FORCE_SENSOR_MULTIPLIER; if (forceForTiltUpdate > MAX_SENSOR_TILT_FORCE) forceForTiltUpdate = MAX_SENSOR_TILT_FORCE; if (forceForTiltUpdate < -MAX_SENSOR_TILT_FORCE) forceForTiltUpdate = -MAX_SENSOR_TILT_FORCE; /*if (Math.abs(forceForTiltUpdate)>0.01) console.log("Sensor Force:", forceForTiltUpdate.toFixed(3));*/ } else { if (tiltLeftActive === true && tiltRightActive === false) { forceForTiltUpdate = -TILT_FORCE_BUTTON_BASE; } else if (tiltRightActive === true && tiltLeftActive === false) { forceForTiltUpdate = TILT_FORCE_BUTTON_BASE; } } if(rings) updateRings(forceForTiltUpdate, deltaTime); drawAllPegsAndLandedRings(); if(rings) rings.forEach(ring => { drawRing(ring); }); updateAndDrawJetParticles(deltaTime); updateAndDrawFloatingScores(deltaTime); drawScoreOnCanvas(); if (currentGameMode === 'arcade' && !gameOver && gameRunning) drawArcadeInfoOnCanvas(); else if (currentGameMode === 'normal' && landedRingsCount >= MAX_TOTAL_RINGS_ON_SCREEN && !gameOver) { checkAllPegsCompleted_NormalMode(); } if(gameRunning && !gameOver){ gameLoopId = requestAnimationFrame(gameLoop); }

    }

    function startGameFlow(mode) {
        console.log(">>>> startGameFlow llamada con modo:", mode);
        if(startScreen) startScreen.style.display = 'none'; 
        if (howToPlayScreen && howToPlayScreen.style.display !== 'none') howToPlayScreen.style.display = 'none'; 
        
        initGame(mode); // Esto SÍ configura las variables base del juego
        
        if (mode === 'arcade') {
            // initGame ya habrá reseteado currentArcadeLevel a 0.
            // Ahora preparamos el primer nivel, lo que mostrará el modal.
            prepareArcadeLevel(0); 
        } else { // Modo Normal
            gameRunning = true; 
            gameOver = false;
            isPausedForLevelTransition = false;
            if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; }
            if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } 
            else { lastTime = Date.now(); }
            console.log(">>>> Requesting gameloop for Normal Mode start");
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    // --- EVENT LISTENERS (con verificaciones) ---
    // ... (Pega aquí todos los listeners que te di en la respuesta anterior, con las verificaciones if (button))

    if (startNormalModeButton) { startNormalModeButton.addEventListener('click', () => { startGameFlow('normal'); }); } else { console.error("ERROR: startNormalModeButton listener NOT attached"); }
    if (startArcadeModeButton) { startArcadeModeButton.addEventListener('click', () => { startGameFlow('arcade'); }); } else { console.error("ERROR: startArcadeModeButton listener NOT attached"); }
    if (beginLevelButton) { beginLevelButton.addEventListener('click', startPreparedArcadeLevel); } else { console.error("ERROR: beginLevelButton NOT FOUND / listener NOT attached"); }
    // ... (resto de listeners)


    // --- Configuración Inicial Final ---
    if (messageBoard) { 
        // messageBoard.style.display = 'none'; // Comentado para que se vea el estado del sensor
        setPersistentInstructions(); 
    }
    if (startScreen) { 
        startScreen.style.display = 'flex'; 
        console.log(">>>> Pantalla de inicio (startScreen) activada.");
    } else { 
        console.error("!!!!!!!! FATAL: startScreen NO ENCONTRADO. No se puede mostrar la pantalla de inicio. !!!!!!!!!"); 
    }
    if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } 
    else { lastTime = Date.now(); }
    console.log(">>>> Iniciando el primer gameloop para UI.");
    gameLoopId = requestAnimationFrame(gameLoop); 
}


// --- LLAMADA A LA FUNCIÓN PRINCIPAL ---
// (El atributo `defer` en la etiqueta <script> del HTML asegura que el DOM está listo)
initializeAndRunGame();
