// Colocar TODO el código dentro de esta función autoejecutable o asegurar que se llame DESPUÉS de la definición de initializeAndRunGame
// Esto es para evitar el error "initializeAndRunGame is not defined"
// La opción más simple para un script con 'defer' es definir la función y luego llamarla.

function initializeAndRunGame() {
    console.log(">>>> initializeAndRunGame() called. Document readyState:", document.readyState);

    const canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error("!!!!!!!! FATAL ERROR: Canvas element with id 'gameCanvas' NOT FOUND !!!!!!!");
        const body = document.querySelector('body');
        if (body) body.innerHTML = '<h1 style="color:red; text-align:center; margin-top: 50px;">Error: No se pudo cargar el juego (Canvas no encontrado).</h1>';
        return; 
    }
    const ctx = canvas.getContext('2d');
    console.log(">>>> Canvas and ctx obtained.");

    const messageBoard = document.getElementById('messageBoard');
    const leftJetButton = document.getElementById('leftJetButton');
    const rightJetButton = document.getElementById('rightJetButton');
    const tiltLeftButton = document.getElementById('tiltLeftButton');
    const tiltRightButton = document.getElementById('tiltRightButton');
    const resetButton = document.getElementById('resetButton');
    const enableSensorButton = document.getElementById('enableSensorButton');
    const fullscreenButton = document.getElementById('fullscreenButton'); 
    const startScreen = document.getElementById('startScreen');
    const startNormalModeButton = document.getElementById('startNormalModeButton');
    const startArcadeModeButton = document.getElementById('startArcadeModeButton'); 
    const howToPlayButton = document.getElementById('howToPlayButton');
    const howToPlayScreen = document.getElementById('howToPlayScreen'); 
    const closeHowToPlayButton = document.getElementById('closeHowToPlayButton'); 
    const levelStartScreen = document.getElementById('levelStartScreen');
    const levelStartTitle = document.getElementById('levelStartTitle');
    const levelStartObjective = document.getElementById('levelStartObjective');
    const beginLevelButton = document.getElementById('beginLevelButton');
    const levelEndScreen = document.getElementById('levelEndScreen');
    const levelEndTitle = document.getElementById('levelEndTitle');
    const levelEndTimeBonus = document.getElementById('levelEndTimeBonus');
    const levelEndTotalScore = document.getElementById('levelEndTotalScore');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const arcadeEndToMenuButton = document.getElementById('arcadeEndToMenuButton');
    
    const gameScreenWidth = 450;
    const gameScreenHeight = 400;
    canvas.width = gameScreenWidth;
    canvas.height = gameScreenHeight;

    const RING_OUTER_RADIUS = 18; const RING_VISUAL_THICKNESS = 6; const MAX_RINGS_PER_PEG = 6; const RING_COLORS = ['#FF4136', '#0074D9', '#2ECC40', '#FFDC00']; const TOTAL_COLORS = RING_COLORS.length; const GRAVITY_BASE = 0.038; const MAX_JET_PRESSURE = 1.0; const JET_PRESSURE_INCREMENT_BASE = 0.05; const JET_PRESSURE_DECREMENT_BASE = 0.08; const BASE_JET_STRENGTH = 3.8; const JET_HORIZONTAL_INFLUENCE_RATIO = 0.28; const JET_EFFECT_RADIUS_Y = gameScreenHeight * 0.75; const JET_EFFECT_RADIUS_X = gameScreenWidth * 0.38; const JET_VERTICAL_FALLOFF_POWER = 0.6; const MAX_JET_PARTICLES = 200; const TILT_FORCE_BUTTON_BASE = 0.30; const TILT_FORCE_SENSOR_MULTIPLIER = 0.055; const MAX_SENSOR_TILT_FORCE = 0.55; const WATER_FRICTION_COEFF = 0.028; const BOUNCE_FACTOR = -0.2; const RING_COLLISION_BOUNCE = 0.5; const PEG_COLLISION_BOUNCE_FACTOR = -0.3; const PEG_STROKE_COLOR = '#505050'; const PEG_FILL_COLOR = '#808080'; const PEG_VISUAL_WIDTH = 10; const PEG_MOVEMENT_SPEED_X = 0.7; const PEG_MOVEMENT_SPEED_Y_MIN = 0.3; const PEG_MOVEMENT_SPEED_Y_MAX = 0.8;const RING_OUTLINE_COLOR = 'rgba(0,0,0,0.85)'; const RING_OUTLINE_WIDTH_ON_SCREEN = 1.0; const FLAT_RING_VIEW_THICKNESS = 7; const GROUND_FLAT_RING_THICKNESS = 5; const MAX_TOTAL_RINGS_ON_SCREEN = MAX_RINGS_PER_PEG * TOTAL_COLORS;
    let score = 0; let scorePulseActive = false; let scorePulseTimer = 0; const SCORE_PULSE_DURATION = 12; let rings = []; let pegs = []; let lastTime = 0; const TARGET_FPS = 60; const TARGET_DT = 1 / TARGET_FPS; let floatingScores = []; let jetParticles = []; let gameLoopId = null; let gameRunning = false; let isPausedForLevelTransition = false; let landedRingsCount = 0; let gameOver = false; let baseScoreFromRings = 0; let bonusScoreFromColorStreak = 0; let bonusScoreFromFullPegsGeneral = 0; let bonusScoreFromMonoColorPegsSpecific = 0; let allPegsCompletedBonusFactor = 1; let masterBonusFactor = 1; let currentScoreDisplaySize = 22; const SCORE_NORMAL_SIZE = 22; const SCORE_PULSE_SIZE = 26;
    let currentGameMode = 'none'; let currentArcadeLevel = 0; let timeLeftInLevel = 0; 
    const ARCADE_LEVEL_TIME_LIMIT = 90; 
    const ARCADE_LEVELS = [ { name: "Nivel 1: Clásico", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 2, pegConfigKey: 'standard' }, { name: "Nivel 2: Línea Central", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 3, pegConfigKey: 'centerLine' }, { name: "Nivel 3: Invertido", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 4, pegConfigKey: 'invertedStandard' }, { name: "Nivel 4: Movedizos Horizontales", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 5, pegConfigKey: 'horizontalMovers' }, { name: "Nivel 5: Bailarines Verticales", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 6, pegConfigKey: 'verticalMovers' } ];
    let leftJetInputActive = false; let rightJetInputActive = false; let leftJetPressure = 0; let rightJetPressure = 0; let tiltLeftActive = false; let tiltRightActive = false; let sensorTiltX = 0; let sensorAvailable = false; let sensorActive = false;
    const KEY_LEFT_ARROW = 'ArrowLeft'; const KEY_RIGHT_ARROW = 'ArrowRight'; const KEY_JET_LEFT = 'KeyA'; const KEY_JET_RIGHT = 'KeyD';

    function createRing(x, y, color) { let speedMagnitude = 0.08 + Math.random() * 0.12; return { x: x, y: y, vx: (Math.random() - 0.5) * 0.4, vy: (Math.random() - 0.5) * 0.4, color: color, originalColor: color, landed: false, pegIndex: -1, landedOrder: -1, basePoints: 25, awardedPoints: 0, rotationAngle: Math.random() * Math.PI * 2, initialRotationSpeed: (Math.random() < 0.5 ? -1 : 1) * speedMagnitude, rotationSpeed: 0, zRotationAngle: (Math.random() - 0.5) * 0.3, zRotationSpeed: (Math.random() - 0.5) * 0.03, isFlat: false, isSlidingOnPeg: false, finalYonPeg: 0 }; }
    function configurePegsForLayout(layoutType) { pegs = []; let pegData = []; const standardPegPositions = [ { xFactor: 0.22, heightFactor: 0.35, yOffsetFactor: 0 }, { xFactor: 0.78, heightFactor: 0.35, yOffsetFactor: 0 }, { xFactor: 0.38, heightFactor: 0.30, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, { xFactor: 0.62, heightFactor: 0.30, yOffsetFactor: 0.35 + (45 / gameScreenHeight) } ]; switch (layoutType) { case 'centerLine': const centerSpacing = gameScreenWidth / 5; pegData = [ { x: centerSpacing * 1, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 2, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 3, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 4, yBaseFactor: 0.3, heightFactor: 0.30 }, ]; pegData.forEach((data, index) => { pegs.push({ id: index, x: data.x, bottomY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: data.x, maxX: data.x, minY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor) }); }); break; case 'invertedStandard': pegData = [ { xFactor: 0.38, heightFactor: 0.30, yOffsetFactor: 0 }, { xFactor: 0.62, heightFactor: 0.30, yOffsetFactor: 0 }, { xFactor: 0.22, heightFactor: 0.35, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, { xFactor: 0.78, heightFactor: 0.35, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, ]; pegData.forEach((data, index) => { pegs.push({ id: index, x: gameScreenWidth * data.xFactor, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: gameScreenWidth * data.xFactor, maxX: gameScreenWidth * data.xFactor, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break; case 'horizontalMovers': const moverMarginX = gameScreenWidth * 0.1; const moverCenterGap = gameScreenWidth * 0.05; standardPegPositions.forEach((data, index) => { const pegX = gameScreenWidth * data.xFactor; let minX, maxX; if (index === 0 || index === 2) { minX = moverMarginX; maxX = gameScreenWidth / 2 - PEG_VISUAL_WIDTH - moverCenterGap / 2; } else { minX = gameScreenWidth / 2 + moverCenterGap / 2; maxX = gameScreenWidth - moverMarginX - PEG_VISUAL_WIDTH; } pegs.push({ id: index, x: (index === 0 || index === 2) ? minX : maxX, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: PEG_MOVEMENT_SPEED_X * ((index === 0 || index === 2) ? 1 : -1), vy: 0, dirX: ((index === 0 || index === 2) ? 1 : -1), dirY: 1, minX: minX, maxX: maxX, originalX: pegX, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break; case 'verticalMovers': const centerBaseX = gameScreenWidth / 2; const topBoundary = gameScreenHeight * 0.2; const bottomBoundary = gameScreenHeight * 0.8; [ { xOffset: -PEG_VISUAL_WIDTH * 1.5, initialYFactor: 0.3 }, { xOffset: -PEG_VISUAL_WIDTH * 0.5, initialYFactor: 0.5 }, { xOffset: PEG_VISUAL_WIDTH * 0.5, initialYFactor: 0.4 }, { xOffset: PEG_VISUAL_WIDTH * 1.5, initialYFactor: 0.6 }, ].forEach((data, index) => { const pegHeight = gameScreenHeight * 0.25; const initialBottomY = gameScreenHeight * data.initialYFactor + pegHeight; pegs.push({ id: index, x: centerBaseX + data.xOffset, bottomY: initialBottomY, height: pegHeight, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: (Math.random() < 0.5 ? -1 : 1) * (PEG_MOVEMENT_SPEED_Y_MIN + Math.random() * (PEG_MOVEMENT_SPEED_Y_MAX - PEG_MOVEMENT_SPEED_Y_MIN)), dirX: 1, dirY: (Math.random() < 0.5 ? -1 : 1), minX: centerBaseX + data.xOffset, maxX: centerBaseX + data.xOffset, minY: topBoundary, maxY: bottomBoundary }); }); break; case 'standard': default: standardPegPositions.forEach((data, index) => { pegs.push({ id: index, x: gameScreenWidth * data.xFactor, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: gameScreenWidth * data.xFactor, maxX: gameScreenWidth * data.xFactor, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break;} }
    function updatePegs(dt) { if (currentGameMode !== 'arcade' || currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length || !pegs) return; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if (!levelConfig) return; const configKey = levelConfig.pegConfigKey; const timeFactor = dt * TARGET_FPS * 0.5; if (configKey === 'horizontalMovers') { pegs.forEach(peg => { const prevX = peg.x; peg.x += peg.vx * timeFactor; if (peg.x + PEG_VISUAL_WIDTH/2 > peg.maxX) { peg.x = peg.maxX - PEG_VISUAL_WIDTH/2; peg.vx *= -1; } else if (peg.x - PEG_VISUAL_WIDTH/2 < peg.minX) { peg.x = peg.minX + PEG_VISUAL_WIDTH/2; peg.vx *= -1; } const deltaX = peg.x - prevX; peg.landedRings.forEach(ring => ring.x += deltaX); }); } else if (configKey === 'verticalMovers') { pegs.forEach(peg => { const prevBottomY = peg.bottomY; let newBottomY = peg.bottomY + peg.vy * timeFactor; let newTopY = newBottomY - peg.height; if (newTopY < peg.minY) { newBottomY = peg.minY + peg.height; peg.vy *= -1; } else if (newBottomY > peg.maxY ) { newBottomY = peg.maxY; peg.vy *= -1; } peg.bottomY = newBottomY; const deltaY = peg.bottomY - prevBottomY; peg.landedRings.forEach(ring => ring.y += deltaY); }); } }
    function initGame(mode) { console.log(">>>> initGame llamada con modo:", mode); currentGameMode = mode; score = 0; baseScoreFromRings = 0; bonusScoreFromColorStreak = 0; bonusScoreFromFullPegsGeneral = 0; bonusScoreFromMonoColorPegsSpecific = 0; allPegsCompletedBonusFactor = 1; masterBonusFactor = 1; scorePulseActive = false; scorePulseTimer = 0; currentScoreDisplaySize = SCORE_NORMAL_SIZE; leftJetPressure = 0; rightJetPressure = 0; tiltLeftActive = false; tiltRightActive = false; floatingScores = []; jetParticles = []; landedRingsCount = 0; gameOver = false; isPausedForLevelTransition = false; hideEndGameScreen(); if (levelStartScreen) levelStartScreen.style.display = 'none'; if (levelEndScreen) levelEndScreen.style.display = 'none'; if (startScreen) startScreen.style.display = 'none'; if (howToPlayScreen && howToPlayScreen.style.display !== 'none') howToPlayScreen.style.display = 'none'; if (messageBoard) setPersistentInstructions(); rings = []; if (currentGameMode === 'arcade') { currentArcadeLevel = 0; arcadeLevelScore = 0; score = 0; } else { configurePegsForLayout('standard'); currentArcadeLevel = -1; timeLeftInLevel = -1; const initialRingCount = MAX_TOTAL_RINGS_ON_SCREEN; const colorsToDistribute = [...RING_COLORS]; let colorCounter = 0; for (let i = 0; i < initialRingCount; i++) { const color = colorsToDistribute[colorCounter % TOTAL_COLORS]; colorCounter++; const x = RING_OUTER_RADIUS + Math.random() * (gameScreenWidth - 2 * RING_OUTER_RADIUS); const y = gameScreenHeight * 0.60 + Math.random() * (gameScreenHeight * 0.40 - RING_OUTER_RADIUS); rings.push(createRing(x, y, color)); } } if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } console.log(">>>> initGame finalizada para modo:", mode); }
    function prepareArcadeLevel(levelIndex) { if (levelIndex < 0 || levelIndex >= ARCADE_LEVELS.length) { console.error("Índice de nivel arcade inválido:", levelIndex); triggerGameOver_ArcadeMode(currentArcadeLevel >= ARCADE_LEVELS.length); return; } console.log(">>>> prepareArcadeLevel llamada para nivel:", levelIndex + 1); isPausedForLevelTransition = true; gameRunning = false; if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null;} currentArcadeLevel = levelIndex; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if (levelStartTitle) levelStartTitle.textContent = levelConfig.name || `Nivel ${levelIndex + 1}`; let objectiveText = "Objetivo: "; if (levelConfig.ringsObjective.type === 'fillPegs') { objectiveText += `Llenar ${levelConfig.ringsObjective.count} palos`; } if (levelConfig.OR_ringsObjective) { objectiveText += " O "; if (levelConfig.OR_ringsObjective.type === 'minPerPeg') { objectiveText += `Poner ${levelConfig.OR_ringsObjective.count} aros en cada palo.`; } } if (levelStartObjective) levelStartObjective.textContent = objectiveText; if(levelEndScreen) levelEndScreen.style.display = 'none'; if (levelStartScreen) levelStartScreen.style.display = 'flex'; if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } if(!gameLoopId) gameLoopId = requestAnimationFrame(gameLoop); }
    function startPreparedArcadeLevel() { console.log(">>>> startPreparedArcadeLevel llamada para nivel:", currentArcadeLevel + 1); isPausedForLevelTransition = false; if(levelStartScreen) levelStartScreen.style.display = 'none'; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if (!levelConfig) { console.error("startPreparedArcadeLevel: No se encontró config para nivel", currentArcadeLevel); return;} configurePegsForLayout(levelConfig.pegConfigKey); timeLeftInLevel = levelConfig.timeLimit; rings = []; landedRingsCount = 0; if (pegs) { pegs.forEach(p => { p.landedRings = []; p.isFullAndScored = false; p.isMonoColor = false; });} else { console.error("startPreparedArcadeLevel: pegs NO definidos"); return;} const initialRingCount = MAX_TOTAL_RINGS_ON_SCREEN; const colorsToDistribute = [...RING_COLORS]; let colorCounter = 0; for (let i = 0; i < initialRingCount; i++) { const color = colorsToDistribute[colorCounter % TOTAL_COLORS]; colorCounter++; const x = RING_OUTER_RADIUS + Math.random() * (gameScreenWidth - 2 * RING_OUTER_RADIUS); const y = gameScreenHeight * 0.60 + Math.random() * (gameScreenHeight * 0.40 - RING_OUTER_RADIUS); rings.push(createRing(x, y, color)); } gameRunning = true; gameOver = false; if (gameLoopId) cancelAnimationFrame(gameLoopId); if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } gameLoopId = requestAnimationFrame(gameLoop); }
    function drawRing(ring) { /* ... */ } function drawAllPegsAndLandedRings() { /* ... */ } function drawArcadeInfoOnCanvas() { /* ... */ } function drawScoreOnCanvas() { /* ... */ } instructionTimeout = null; function showMessage(text, duration = 3000, isInstruction = false) { /* ... */ } function setPersistentInstructions() { /* ... */ } function updateScore(pointsToAdd, message = "") { /* ... */ } function checkArcadeLevelWinCondition() { /* ... */ } function checkAndApplyBonuses(landedRing, peg) { /* ... */ } function checkAllPegsCompleted_NormalMode() { /* ... */ } function goToNextArcadeLevel() { /* ... */ } function triggerGameOver_NormalMode() { /* ... */ } function triggerGameOver_ArcadeMode(allLevelsCompleted = false) { /* ... */ } function showEndGameScreen(mode, arcadeWon = false, levelReachedIfLost = 0) { /* ... */ } function hideEndGameScreen() { /* ... */ } function hexToRgb(hex) { /* ... */ } function createFloatingScore(x, y, text, color = "#FFFFFF", durationFrames = 90, upwardSpeed = 0.8) { /* ... */ } function updateAndDrawFloatingScores(dt) { /* ... */ } function createJetParticle(xSide, strength) { /* ... */ } function updateAndDrawJetParticles(dt) { /* ... */ } function updateRings(actualTiltForceToApply, dt) { /* ... */ }
    // ... (Definiciones completas de todas las funciones que marqué con /* ... */ van aquí) ...
    function handleOrientation(event) { let gamma = event.gamma; if (gamma === null || gamma === undefined) {return;} const MAX_EFFECTIVE_GAMMA_SENSOR = 30; sensorTiltX = gamma / MAX_EFFECTIVE_GAMMA_SENSOR; sensorTiltX = Math.max(-1, Math.min(1, sensorTiltX));}
    function requestSensorPermission() { console.log(">>>> requestSensorPermission llamada."); if(!enableSensorButton) { console.error("requestSensorPermission: enableSensorButton no existe."); return; } enableSensorButton.classList.add('sensor-button--activating'); setTimeout(() => { if(enableSensorButton) enableSensorButton.classList.remove('sensor-button--activating'); }, 300); if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') { console.log("Sensor: Usando DeviceOrientationEvent.requestPermission()"); DeviceOrientationEvent.requestPermission().then(permissionState => { console.log("Sensor: Estado del permiso:", permissionState); if (permissionState === 'granted') { window.addEventListener('deviceorientation', handleOrientation, true); sensorActive = true; console.log("Sensor: Permiso concedido. sensorActive AHORA ES TRUE"); if(enableSensorButton) enableSensorButton.style.display = 'none'; if(tiltLeftButton) tiltLeftButton.style.display = 'none'; if(tiltRightButton) tiltRightButton.style.display = 'none'; if (messageBoard) setPersistentInstructions(); } else { sensorActive = false; if (messageBoard) showMessage("Permiso del sensor denegado.", 3000, true); if(enableSensorButton) {enableSensorButton.textContent = "Sensor Denegado"; enableSensorButton.disabled = true;} console.warn("Sensor: Permiso denegado. sensorActive AHORA ES FALSE"); if (messageBoard) setPersistentInstructions(); } }).catch(error => { sensorActive = false; console.error("Sensor: Error al solicitar permiso:", error); if (messageBoard) showMessage("Error al activar sensor.", 3000, true); if (messageBoard) setPersistentInstructions(); }); } else if (window.DeviceOrientationEvent){ console.log("Sensor: Navegador soporta DeviceOrientationEvent directamente."); window.addEventListener('deviceorientation', handleOrientation, true); sensorActive = true; console.log("Sensor: Listener añadido directamente. sensorActive AHORA ES TRUE"); if(enableSensorButton) enableSensorButton.style.display = 'none'; if(tiltLeftButton) tiltLeftButton.style.display = 'none'; if(tiltRightButton) tiltRightButton.style.display = 'none'; if (messageBoard) setPersistentInstructions(); } else { sensorAvailable = false; sensorActive = false; console.warn("Sensor: DeviceOrientationEvent no soportado."); if (messageBoard) showMessage("Sensor no soportado.", 3000, true); if(enableSensorButton) enableSensorButton.style.display = 'none'; if (messageBoard) setPersistentInstructions(); } }

    // --- EVENT LISTENERS ---
    if (leftJetButton) { leftJetButton.addEventListener('mousedown', () => { leftJetInputActive = true; }); leftJetButton.addEventListener('mouseup', () => { leftJetInputActive = false; }); leftJetButton.addEventListener('mouseleave', () => { if(leftJetInputActive) {leftJetInputActive = false;} }); leftJetButton.addEventListener('touchstart', (e) => { e.preventDefault(); leftJetInputActive = true; }, { passive: false }); leftJetButton.addEventListener('touchend', (e) => { e.preventDefault(); leftJetInputActive = false; }); }
    if (rightJetButton) { rightJetButton.addEventListener('mousedown', () => { rightJetInputActive = true; }); rightJetButton.addEventListener('mouseup', () => { rightJetInputActive = false; }); rightJetButton.addEventListener('mouseleave', () => { if(rightJetInputActive) {rightJetInputActive = false;} }); rightJetButton.addEventListener('touchstart', (e) => { e.preventDefault(); rightJetInputActive = true; }, { passive: false }); rightJetButton.addEventListener('touchend', (e) => { e.preventDefault(); rightJetInputActive = false; }); }
    if (tiltLeftButton) { tiltLeftButton.addEventListener('mousedown', () => { tiltLeftActive = true; }); tiltLeftButton.addEventListener('mouseup', () => { tiltLeftActive = false; }); tiltLeftButton.addEventListener('mouseleave', () => { if (tiltLeftActive) { tiltLeftActive = false; } }); tiltLeftButton.addEventListener('touchstart', (e) => { e.preventDefault(); tiltLeftActive = true; }, { passive: false }); tiltLeftButton.addEventListener('touchend', (e) => { e.preventDefault(); tiltLeftActive = false; }); }
    if (tiltRightButton) { tiltRightButton.addEventListener('mousedown', () => { tiltRightActive = true; }); tiltRightButton.addEventListener('mouseup', () => { tiltRightActive = false; }); tiltRightButton.addEventListener('mouseleave', () => { if (tiltRightActive) { tiltRightActive = false; } }); tiltRightButton.addEventListener('touchstart', (e) => { e.preventDefault(); tiltRightActive = true;}, { passive: false }); tiltRightButton.addEventListener('touchend', (e) => { e.preventDefault(); tiltRightActive = false; });}
    if (resetButton) { resetButton.addEventListener('click', () => { console.log(">>>> resetButton clicked"); if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } gameRunning = false; gameOver = false; isPausedForLevelTransition = false; hideEndGameScreen(); if(levelStartScreen) levelStartScreen.style.display = 'none'; if(levelEndScreen) levelEndScreen.style.display = 'none'; if(startScreen) startScreen.style.display = 'flex'; else { console.error("Reset: startScreen not found!"); return;} if(howToPlayButton) howToPlayButton.style.display = 'inline-block'; if (enableSensorButton && sensorAvailable) { enableSensorButton.style.display = 'inline-block'; enableSensorButton.disabled = false; enableSensorButton.textContent = "SENSOR";} if (tiltLeftButton) tiltLeftButton.style.display = 'flex'; if(tiltRightButton) tiltRightButton.style.display = 'flex'; sensorActive = false; score = 0; currentScoreDisplaySize = SCORE_NORMAL_SIZE; currentArcadeLevel = 0; timeLeftInLevel = 0; currentGameMode = 'none'; if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); drawScoreOnCanvas(); if (!gameLoopId) { if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } gameLoopId = requestAnimationFrame(gameLoop); }}); }
    if (fullscreenButton) { fullscreenButton.addEventListener('click', () => { const elem = document.querySelector('.game-container'); if (elem && !document.fullscreenElement) { if (elem.requestFullscreen) { elem.requestFullscreen(); } else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); } } else { if (document.exitFullscreen) { document.exitFullscreen(); } }}); }
    if (beginLevelButton) { beginLevelButton.addEventListener('click', startPreparedArcadeLevel); }
    if (nextLevelButton) { nextLevelButton.addEventListener('click', () => { if(levelEndScreen) levelEndScreen.style.display = 'none'; if (currentArcadeLevel < ARCADE_LEVELS.length) { prepareArcadeLevel(currentArcadeLevel); } else { if(resetButton) resetButton.click(); } }); }
    if (arcadeEndToMenuButton) { arcadeEndToMenuButton.addEventListener('click', () => { if(levelEndScreen) levelEndScreen.style.display = 'none'; if(resetButton) resetButton.click(); }); }
    if (startNormalModeButton) { startNormalModeButton.addEventListener('click', () => { startGameFlow('normal'); }); }
    if (startArcadeModeButton) { startArcadeModeButton.addEventListener('click', () => { startGameFlow('arcade'); }); }
    if (howToPlayButton) { howToPlayButton.addEventListener('click', () => { if(howToPlayScreen) howToPlayScreen.style.display = 'flex';}); }
    if (closeHowToPlayButton) { closeHowToPlayButton.addEventListener('click', () => { if(howToPlayScreen) howToPlayScreen.style.display = 'none';}); }
    window.addEventListener('click', (event) => { if (howToPlayScreen && event.target == howToPlayScreen) { howToPlayScreen.style.display = 'none'; }});
    window.addEventListener('keydown', (e) => { let keyProcessed = false; switch (e.code) { case KEY_LEFT_ARROW: tiltLeftActive = true; keyProcessed = true; break; case KEY_RIGHT_ARROW: tiltRightActive = true; keyProcessed = true; break; case KEY_JET_LEFT: leftJetInputActive = true; keyProcessed = true; break; case KEY_JET_RIGHT: rightJetInputActive = true; keyProcessed = true; break; } if (keyProcessed && (gameRunning || (startScreen && startScreen.style.display === 'none'))) e.preventDefault(); });
    window.addEventListener('keyup', (e) => { let keyProcessed = false; switch (e.code) { case KEY_LEFT_ARROW: tiltLeftActive = false; keyProcessed = true; break; case KEY_RIGHT_ARROW: tiltRightActive = false; keyProcessed = true; break; case KEY_JET_LEFT: leftJetInputActive = false; keyProcessed = true; break; case KEY_JET_RIGHT: rightJetInputActive = false; keyProcessed = true; break; } if (keyProcessed && (gameRunning || (startScreen && startScreen.style.display === 'none'))) e.preventDefault(); });
    if (enableSensorButton) { if (window.DeviceOrientationEvent) { sensorAvailable = true; enableSensorButton.style.display = 'inline-block'; enableSensorButton.disabled = false; enableSensorButton.textContent = "SENSOR"; enableSensorButton.addEventListener('click', requestSensorPermission); } else { sensorAvailable = false; enableSensorButton.style.display = 'none'; } } else { sensorAvailable = false; console.warn("Enable sensor button not found during initial setup.");}

    function gameLoop(currentTime) { 
        if (isPausedForLevelTransition) { if ((levelStartScreen && levelStartScreen.style.display === 'flex') || (levelEndScreen && levelEndScreen.style.display === 'flex')) { if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); drawScoreOnCanvas(); if(currentGameMode === 'arcade' && ARCADE_LEVELS[currentArcadeLevel] && levelStartScreen.style.display === 'flex') { drawArcadeInfoOnCanvas(); } } if(!gameLoopId && isPausedForLevelTransition) { gameLoopId = requestAnimationFrame(gameLoop); } else if (isPausedForLevelTransition) { requestAnimationFrame(gameLoop); } return; }
        if (!gameRunning && !gameOver) { if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); if (startScreen && (startScreen.style.display === 'none' || startScreen.style.display === '')) { drawScoreOnCanvas(); } gameLoopId = requestAnimationFrame(gameLoop); return; }
        if (gameOver) { return; }
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now(); let dt = (now - lastTime) / 1000.0; if (dt <= 0 || isNaN(dt) || dt > (TARGET_DT * 5) ) dt = TARGET_DT; lastTime = now; const deltaTime = dt; 
        if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (scorePulseActive) { scorePulseTimer -= deltaTime * TARGET_FPS; if (scorePulseTimer <= 0) { scorePulseActive = false; currentScoreDisplaySize = SCORE_NORMAL_SIZE; } else { const pulseProgress = 1 - (scorePulseTimer / SCORE_PULSE_DURATION); currentScoreDisplaySize = SCORE_NORMAL_SIZE + Math.sin(pulseProgress * Math.PI) * (SCORE_PULSE_SIZE - SCORE_NORMAL_SIZE); } }
        const accelerationFactor = deltaTime * TARGET_FPS; const pressureChange = JET_PRESSURE_INCREMENT_BASE * accelerationFactor; const pressureDecay = JET_PRESSURE_DECREMENT_BASE * accelerationFactor;
        if (leftJetInputActive) { leftJetPressure += pressureChange; if (leftJetPressure > MAX_JET_PRESSURE) leftJetPressure = MAX_JET_PRESSURE; if(leftJetPressure > 0.1) createJetParticle(-1, leftJetPressure); } else { leftJetPressure -= pressureDecay; if (leftJetPressure < 0) leftJetPressure = 0; }
        if (rightJetInputActive) { rightJetPressure += pressureChange; if (rightJetPressure > MAX_JET_PRESSURE) rightJetPressure = MAX_JET_PRESSURE; if(rightJetPressure > 0.1) createJetParticle(1, rightJetPressure); } else { rightJetPressure -= pressureDecay; if (rightJetPressure < 0) rightJetPressure = 0; }
        if (currentGameMode === 'arcade' && !gameOver && gameRunning) { timeLeftInLevel -= deltaTime; if (timeLeftInLevel <= 0) { timeLeftInLevel = 0; triggerGameOver_ArcadeMode(false); } }
        if (pegs && pegs.length > 0 && ARCADE_LEVELS[currentArcadeLevel] && (ARCADE_LEVELS[currentArcadeLevel].pegConfigKey === 'horizontalMovers' || ARCADE_LEVELS[currentArcadeLevel].pegConfigKey === 'verticalMovers')) { updatePegs(deltaTime); } 
        let forceForTiltUpdate = 0; if (sensorActive && sensorAvailable) { forceForTiltUpdate = sensorTiltX * TILT_FORCE_SENSOR_MULTIPLIER; if (forceForTiltUpdate > MAX_SENSOR_TILT_FORCE) forceForTiltUpdate = MAX_SENSOR_TILT_FORCE; if (forceForTiltUpdate < -MAX_SENSOR_TILT_FORCE) forceForTiltUpdate = -MAX_SENSOR_TILT_FORCE; if (Math.abs(forceForTiltUpdate)>0.01) console.log("Sensor Force:", forceForTiltUpdate.toFixed(3));} else { if (tiltLeftActive === true && tiltRightActive === false) { forceForTiltUpdate = -TILT_FORCE_BUTTON_BASE; } else if (tiltRightActive === true && tiltLeftActive === false) { forceForTiltUpdate = TILT_FORCE_BUTTON_BASE; } }
        if(rings) updateRings(forceForTiltUpdate, deltaTime); 
        drawAllPegsAndLandedRings();
        if(rings) rings.forEach(ring => { drawRing(ring); });
        updateAndDrawJetParticles(deltaTime);
        updateAndDrawFloatingScores(deltaTime);
        drawScoreOnCanvas(); 
        if (currentGameMode === 'arcade' && !gameOver && gameRunning) drawArcadeInfoOnCanvas();
        else if (currentGameMode === 'normal' && landedRingsCount >= MAX_TOTAL_RINGS_ON_SCREEN && !gameOver) { checkAllPegsCompleted_NormalMode(); }
        if(gameRunning && !gameOver){ gameLoopId = requestAnimationFrame(gameLoop); }
    }
    
    function startGameFlow(mode) {
        console.log(">>>> startGameFlow llamada con modo:", mode);
        if(startScreen) startScreen.style.display = 'none'; 
        if (howToPlayScreen && howToPlayScreen.style.display !== 'none') howToPlayScreen.style.display = 'none'; 
        initGame(mode); 
        if (mode === 'arcade') { prepareArcadeLevel(0); } 
        else { gameRunning = true; gameOver = false; isPausedForLevelTransition = false; if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null;} if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } gameLoopId = requestAnimationFrame(gameLoop); }
    }

    if (messageBoard) setPersistentInstructions(); 
    if (startScreen) { startScreen.style.display = 'flex'; } 
    if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); }
    gameLoopId = requestAnimationFrame(gameLoop); 
}

initializeAndRunGame();
