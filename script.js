// Asegurarse de que este script se ejecute después de que el HTML se parsea (usar 'defer' en HTML)
console.log(">>>> Watertoy Arcade - script.js execution started.");

// --- DEFINICIÓN DE LA FUNCIÓN PRINCIPAL ---
function initializeAndRunGame() {
    console.log(">>>> initializeAndRunGame() called. Document readyState:", document.readyState);

    const canvas = document.getElementById('gameCanvas');
    if (!canvas) {
        console.error("!!!!!!!! FATAL ERROR: Canvas element with id 'gameCanvas' NOT FOUND !!!!!!!");
        const body = document.querySelector('body');
        if (body) body.innerHTML = '<h1 style="color:red; text-align:center; margin-top: 50px;">Error: No se pudo cargar el juego (Canvas no encontrado).</h1>';
        return; 
    }
    console.log(">>>> Canvas found.");
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error("!!!!!!!! FATAL ERROR: 2D context NOT obtained from canvas !!!!!!!");
        return;
    }

    const messageBoard = document.getElementById('messageBoard');
    const leftJetButton = document.getElementById('leftJetButton');
    const rightJetButton = document.getElementById('rightJetButton');
    const tiltLeftButton = document.getElementById('tiltLeftButton');
    const tiltRightButton = document.getElementById('tiltRightButton');
    const resetButton = document.getElementById('resetButton');
    const enableSensorButton = document.getElementById('enableSensorButton');
    const fullscreenButton = document.getElementById('fullscreenButton'); 
    const startScreen = document.getElementById('startScreen');
    const startNormalModeButton = document.getElementById('startNormalModeButton');
    const startArcadeModeButton = document.getElementById('startArcadeModeButton'); 
    const howToPlayButton = document.getElementById('howToPlayButton');
    const howToPlayScreen = document.getElementById('howToPlayScreen'); 
    const closeHowToPlayButton = document.getElementById('closeHowToPlayButton'); 
    const levelStartScreen = document.getElementById('levelStartScreen');
    const levelStartTitle = document.getElementById('levelStartTitle');
    const levelStartObjective = document.getElementById('levelStartObjective');
    const beginLevelButton = document.getElementById('beginLevelButton');
    const levelEndScreen = document.getElementById('levelEndScreen');
    const levelEndTitle = document.getElementById('levelEndTitle');
    const levelEndTimeBonus = document.getElementById('levelEndTimeBonus');
    const levelEndTotalScore = document.getElementById('levelEndTotalScore');
    const nextLevelButton = document.getElementById('nextLevelButton');
    const arcadeEndToMenuButton = document.getElementById('arcadeEndToMenuButton');
    
    console.log(">>>> Primary DOM elements obtained.");

    const gameScreenWidth = 450;
    const gameScreenHeight = 400;
    canvas.width = gameScreenWidth;
    canvas.height = gameScreenHeight;

    const RING_OUTER_RADIUS = 18; const RING_VISUAL_THICKNESS = 6; const MAX_RINGS_PER_PEG = 6; const RING_COLORS = ['#FF4136', '#0074D9', '#2ECC40', '#FFDC00']; const TOTAL_COLORS = RING_COLORS.length; const GRAVITY_BASE = 0.038; const MAX_JET_PRESSURE = 1.0; const JET_PRESSURE_INCREMENT_BASE = 0.05; const JET_PRESSURE_DECREMENT_BASE = 0.08; const BASE_JET_STRENGTH = 3.8; const JET_HORIZONTAL_INFLUENCE_RATIO = 0.28; const JET_EFFECT_RADIUS_Y = gameScreenHeight * 0.75; const JET_EFFECT_RADIUS_X = gameScreenWidth * 0.38; const JET_VERTICAL_FALLOFF_POWER = 0.6; const MAX_JET_PARTICLES = 200; const TILT_FORCE_BUTTON_BASE = 0.30; const TILT_FORCE_SENSOR_MULTIPLIER = 0.055; const MAX_SENSOR_TILT_FORCE = 0.55; const WATER_FRICTION_COEFF = 0.028; const BOUNCE_FACTOR = -0.2; const RING_COLLISION_BOUNCE = 0.5; const PEG_COLLISION_BOUNCE_FACTOR = -0.3; const PEG_STROKE_COLOR = '#505050'; const PEG_FILL_COLOR = '#808080'; const PEG_VISUAL_WIDTH = 10; const PEG_MOVEMENT_SPEED_X = 0.7; const PEG_MOVEMENT_SPEED_Y_MIN = 0.3; const PEG_MOVEMENT_SPEED_Y_MAX = 0.8;const RING_OUTLINE_COLOR = 'rgba(0,0,0,0.85)'; const RING_OUTLINE_WIDTH_ON_SCREEN = 1.0; const FLAT_RING_VIEW_THICKNESS = 7; const GROUND_FLAT_RING_THICKNESS = 5; const MAX_TOTAL_RINGS_ON_SCREEN = MAX_RINGS_PER_PEG * TOTAL_COLORS;
    let score = 0; let scorePulseActive = false; let scorePulseTimer = 0; const SCORE_PULSE_DURATION = 12; let rings = []; let pegs = []; let lastTime = 0; const TARGET_FPS = 60; const TARGET_DT = 1 / TARGET_FPS; let floatingScores = []; let jetParticles = []; let gameLoopId = null; let gameRunning = false; let isPausedForLevelTransition = false; let landedRingsCount = 0; let gameOver = false; let baseScoreFromRings = 0; let bonusScoreFromColorStreak = 0; let bonusScoreFromFullPegsGeneral = 0; let bonusScoreFromMonoColorPegsSpecific = 0; let allPegsCompletedBonusFactor = 1; let masterBonusFactor = 1; let currentScoreDisplaySize = 22; const SCORE_NORMAL_SIZE = 22; const SCORE_PULSE_SIZE = 26;
    let currentGameMode = 'none'; let currentArcadeLevel = 0; let timeLeftInLevel = 0; 
    const ARCADE_LEVEL_TIME_LIMIT = 90; 
    const ARCADE_LEVELS = [ { name: "Nivel 1: Clásico", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 2, pegConfigKey: 'standard' }, { name: "Nivel 2: Línea Central", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 3, pegConfigKey: 'centerLine' }, { name: "Nivel 3: Invertido", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 4, pegConfigKey: 'invertedStandard' }, { name: "Nivel 4: Movedizos Horizontales", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 5, pegConfigKey: 'horizontalMovers' }, { name: "Nivel 5: Bailarines Verticales", ringsObjective: { type: 'fillPegs', count: 2 }, OR_ringsObjective: { type: 'minPerPeg', count: 3 }, timeLimit: ARCADE_LEVEL_TIME_LIMIT, bonusPerSecond: 6, pegConfigKey: 'verticalMovers' } ];
    let leftJetInputActive = false; let rightJetInputActive = false; let leftJetPressure = 0; let rightJetPressure = 0; let tiltLeftActive = false; let tiltRightActive = false; let sensorTiltX = 0; let sensorAvailable = false; let sensorActive = false;
    const KEY_LEFT_ARROW = 'ArrowLeft'; const KEY_RIGHT_ARROW = 'ArrowRight'; const KEY_JET_LEFT = 'KeyA'; const KEY_JET_RIGHT = 'KeyD';

    function createRing(x, y, color) { let speedMagnitude = 0.08 + Math.random() * 0.12; return { x: x, y: y, vx: (Math.random() - 0.5) * 0.4, vy: (Math.random() - 0.5) * 0.4, color: color, originalColor: color, landed: false, pegIndex: -1, landedOrder: -1, basePoints: 25, awardedPoints: 0, rotationAngle: Math.random() * Math.PI * 2, initialRotationSpeed: (Math.random() < 0.5 ? -1 : 1) * speedMagnitude, rotationSpeed: 0, zRotationAngle: (Math.random() - 0.5) * 0.3, zRotationSpeed: (Math.random() - 0.5) * 0.03, isFlat: false, isSlidingOnPeg: false, finalYonPeg: 0 }; }
    function configurePegsForLayout(layoutType) { pegs = []; let pegData = []; const standardPegPositions = [ { xFactor: 0.22, heightFactor: 0.35, yOffsetFactor: 0 }, { xFactor: 0.78, heightFactor: 0.35, yOffsetFactor: 0 }, { xFactor: 0.38, heightFactor: 0.30, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, { xFactor: 0.62, heightFactor: 0.30, yOffsetFactor: 0.35 + (45 / gameScreenHeight) } ]; switch (layoutType) { case 'centerLine': const centerSpacing = gameScreenWidth / 5; pegData = [ { x: centerSpacing * 1, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 2, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 3, yBaseFactor: 0.3, heightFactor: 0.30 }, { x: centerSpacing * 4, yBaseFactor: 0.3, heightFactor: 0.30 }, ]; pegData.forEach((data, index) => { pegs.push({ id: index, x: data.x, bottomY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: data.x, maxX: data.x, minY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - (gameScreenHeight * data.yBaseFactor) }); }); break; case 'invertedStandard': pegData = [ { xFactor: 0.38, heightFactor: 0.30, yOffsetFactor: 0 }, { xFactor: 0.62, heightFactor: 0.30, yOffsetFactor: 0 }, { xFactor: 0.22, heightFactor: 0.35, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, { xFactor: 0.78, heightFactor: 0.35, yOffsetFactor: 0.35 + (45 / gameScreenHeight) }, ]; pegData.forEach((data, index) => { pegs.push({ id: index, x: gameScreenWidth * data.xFactor, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: gameScreenWidth * data.xFactor, maxX: gameScreenWidth * data.xFactor, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break; case 'horizontalMovers': const moverMarginX = gameScreenWidth * 0.1; const moverCenterGap = gameScreenWidth * 0.05; standardPegPositions.forEach((data, index) => { const pegX = gameScreenWidth * data.xFactor; let minX, maxX; if (index === 0 || index === 2) { minX = moverMarginX; maxX = gameScreenWidth / 2 - PEG_VISUAL_WIDTH - moverCenterGap / 2; } else { minX = gameScreenWidth / 2 + moverCenterGap / 2; maxX = gameScreenWidth - moverMarginX - PEG_VISUAL_WIDTH; } pegs.push({ id: index, x: (index === 0 || index === 2) ? minX : maxX, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: PEG_MOVEMENT_SPEED_X * ((index === 0 || index === 2) ? 1 : -1), vy: 0, dirX: ((index === 0 || index === 2) ? 1 : -1), dirY: 1, minX: minX, maxX: maxX, originalX: pegX, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break; case 'verticalMovers': const centerBaseX = gameScreenWidth / 2; const topBoundary = gameScreenHeight * 0.2; const bottomBoundary = gameScreenHeight * 0.8; [ { xOffset: -PEG_VISUAL_WIDTH * 1.5, initialYFactor: 0.3 }, { xOffset: -PEG_VISUAL_WIDTH * 0.5, initialYFactor: 0.5 }, { xOffset: PEG_VISUAL_WIDTH * 0.5, initialYFactor: 0.4 }, { xOffset: PEG_VISUAL_WIDTH * 1.5, initialYFactor: 0.6 }, ].forEach((data, index) => { const pegHeight = gameScreenHeight * 0.25; const initialBottomY = gameScreenHeight * data.initialYFactor + pegHeight; pegs.push({ id: index, x: centerBaseX + data.xOffset, bottomY: initialBottomY, height: pegHeight, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: (Math.random() < 0.5 ? -1 : 1) * (PEG_MOVEMENT_SPEED_Y_MIN + Math.random() * (PEG_MOVEMENT_SPEED_Y_MAX - PEG_MOVEMENT_SPEED_Y_MIN)), dirX: 1, dirY: (Math.random() < 0.5 ? -1 : 1), minX: centerBaseX + data.xOffset, maxX: centerBaseX + data.xOffset, minY: topBoundary, maxY: bottomBoundary }); }); break; case 'standard': default: standardPegPositions.forEach((data, index) => { pegs.push({ id: index, x: gameScreenWidth * data.xFactor, bottomY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor), height: gameScreenHeight * data.heightFactor, landedRings: [], isFullAndScored: false, isMonoColor: false, monoColorValue: null, vx: 0, vy: 0, dirX: 1, dirY: 1, minX: gameScreenWidth * data.xFactor, maxX: gameScreenWidth * data.xFactor, minY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) - (gameScreenHeight * data.heightFactor), maxY: gameScreenHeight - 20 - (gameScreenHeight * data.yOffsetFactor) }); }); break;} }
    function updatePegs(dt) { if (currentGameMode !== 'arcade' || currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length || !pegs) return; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if (!levelConfig) return; const configKey = levelConfig.pegConfigKey; const timeFactor = dt * TARGET_FPS * 0.5; if (configKey === 'horizontalMovers') { pegs.forEach(peg => { const prevX = peg.x; peg.x += peg.vx * timeFactor; if (peg.x + PEG_VISUAL_WIDTH/2 > peg.maxX) { peg.x = peg.maxX - PEG_VISUAL_WIDTH/2; peg.vx *= -1; } else if (peg.x - PEG_VISUAL_WIDTH/2 < peg.minX) { peg.x = peg.minX + PEG_VISUAL_WIDTH/2; peg.vx *= -1; } const deltaX = peg.x - prevX; peg.landedRings.forEach(ring => ring.x += deltaX); }); } else if (configKey === 'verticalMovers') { pegs.forEach(peg => { const prevBottomY = peg.bottomY; let newBottomY = peg.bottomY + peg.vy * timeFactor; let newTopY = newBottomY - peg.height; if (newTopY < peg.minY) { newBottomY = peg.minY + peg.height; peg.vy *= -1; } else if (newBottomY > peg.maxY ) { newBottomY = peg.maxY; peg.vy *= -1; } peg.bottomY = newBottomY; const deltaY = peg.bottomY - prevBottomY; peg.landedRings.forEach(ring => ring.y += deltaY); }); } }
    function initGame(mode) { console.log(">>>> initGame llamada con modo:", mode); currentGameMode = mode; score = 0; baseScoreFromRings = 0; bonusScoreFromColorStreak = 0; bonusScoreFromFullPegsGeneral = 0; bonusScoreFromMonoColorPegsSpecific = 0; allPegsCompletedBonusFactor = 1; masterBonusFactor = 1; scorePulseActive = false; scorePulseTimer = 0; currentScoreDisplaySize = SCORE_NORMAL_SIZE; leftJetPressure = 0; rightJetPressure = 0; tiltLeftActive = false; tiltRightActive = false; floatingScores = []; jetParticles = []; landedRingsCount = 0; gameOver = false; isPausedForLevelTransition = false; hideEndGameScreen(); if (levelStartScreen) levelStartScreen.style.display = 'none'; if (levelEndScreen) levelEndScreen.style.display = 'none'; if (startScreen) startScreen.style.display = 'none'; if (howToPlayScreen && howToPlayScreen.style.display !== 'none') howToPlayScreen.style.display = 'none'; if(messageBoard) setPersistentInstructions(); rings = []; if (currentGameMode === 'arcade') { currentArcadeLevel = 0; score = 0; } else { configurePegsForLayout('standard'); currentArcadeLevel = -1; timeLeftInLevel = -1; const initialRingCount = MAX_TOTAL_RINGS_ON_SCREEN; const colorsToDistribute = [...RING_COLORS]; let colorCounter = 0; for (let i = 0; i < initialRingCount; i++) { const color = colorsToDistribute[colorCounter % TOTAL_COLORS]; colorCounter++; const x = RING_OUTER_RADIUS + Math.random() * (gameScreenWidth - 2 * RING_OUTER_RADIUS); const y = gameScreenHeight * 0.60 + Math.random() * (gameScreenHeight * 0.40 - RING_OUTER_RADIUS); rings.push(createRing(x, y, color)); } } if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } console.log(">>>> initGame finalizada para modo:", mode); }
    function prepareArcadeLevel(levelIndex) { if (levelIndex < 0 || levelIndex >= ARCADE_LEVELS.length) { console.error("Índice de nivel arcade inválido:", levelIndex); triggerGameOver_ArcadeMode(currentArcadeLevel >= ARCADE_LEVELS.length); return; } console.log(">>>> prepareArcadeLevel llamada para nivel:", levelIndex + 1); isPausedForLevelTransition = true; gameRunning = false; if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null;} currentArcadeLevel = levelIndex; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if (levelStartTitle) levelStartTitle.textContent = levelConfig.name || `Nivel ${levelIndex + 1}`; let objectiveText = "Objetivo: "; if (levelConfig.ringsObjective.type === 'fillPegs') { objectiveText += `Llenar ${levelConfig.ringsObjective.count} palos`; } if (levelConfig.OR_ringsObjective) { objectiveText += " O "; if (levelConfig.OR_ringsObjective.type === 'minPerPeg') { objectiveText += `Poner ${levelConfig.OR_ringsObjective.count} aros en cada palo.`; } } if (levelStartObjective) levelStartObjective.textContent = objectiveText; if(levelEndScreen) levelEndScreen.style.display = 'none'; if (levelStartScreen) levelStartScreen.style.display = 'flex'; else console.error("prepareArcadeLevel: levelStartScreen NO encontrado"); if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } if(!gameLoopId) gameLoopId = requestAnimationFrame(gameLoop); }
    function startPreparedArcadeLevel() { console.log(">>>> startPreparedArcadeLevel llamada para nivel:", currentArcadeLevel + 1); isPausedForLevelTransition = false; if(levelStartScreen) levelStartScreen.style.display = 'none'; else console.warn("startPreparedArcadeLevel: levelStartScreen es null"); const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if (!levelConfig) { console.error("startPreparedArcadeLevel: No se encontró config para nivel", currentArcadeLevel); return;} configurePegsForLayout(levelConfig.pegConfigKey); timeLeftInLevel = levelConfig.timeLimit; rings = []; landedRingsCount = 0; if (pegs) { pegs.forEach(p => { p.landedRings = []; p.isFullAndScored = false; p.isMonoColor = false; });} else { console.error("startPreparedArcadeLevel: pegs NO definidos"); return;} const initialRingCount = MAX_TOTAL_RINGS_ON_SCREEN; const colorsToDistribute = [...RING_COLORS]; let colorCounter = 0; for (let i = 0; i < initialRingCount; i++) { const color = colorsToDistribute[colorCounter % TOTAL_COLORS]; colorCounter++; const x = RING_OUTER_RADIUS + Math.random() * (gameScreenWidth - 2 * RING_OUTER_RADIUS); const y = gameScreenHeight * 0.60 + Math.random() * (gameScreenHeight * 0.40 - RING_OUTER_RADIUS); rings.push(createRing(x, y, color)); } gameRunning = true; gameOver = false; if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null; if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } gameLoopId = requestAnimationFrame(gameLoop); }
    function drawRing(ring) { ctx.save(); ctx.translate(ring.x, ring.y); if ((!ring.isFlat || ring.landed) && !ring.isSlidingOnPeg) { ctx.rotate(ring.zRotationAngle); } const outerRadius = RING_OUTER_RADIUS; const innerRadiusMaterial = RING_OUTER_RADIUS - RING_VISUAL_THICKNESS; if (ring.isFlat) { const currentFlatThickness = ring.landed ? FLAT_RING_VIEW_THICKNESS : GROUND_FLAT_RING_THICKNESS; const halfFlatViewThickness = currentFlatThickness / 2; const flatDrawWidth = outerRadius * 2; ctx.fillStyle = RING_OUTLINE_COLOR; ctx.fillRect( -flatDrawWidth / 2 - RING_OUTLINE_WIDTH_ON_SCREEN, -halfFlatViewThickness - RING_OUTLINE_WIDTH_ON_SCREEN, flatDrawWidth + (RING_OUTLINE_WIDTH_ON_SCREEN * 2), currentFlatThickness + (RING_OUTLINE_WIDTH_ON_SCREEN * 2) ); ctx.fillStyle = ring.color; ctx.fillRect( -flatDrawWidth / 2, -halfFlatViewThickness, flatDrawWidth, currentFlatThickness ); } else { const scaleYValue = Math.abs(Math.cos(ring.rotationAngle)); const effectiveScaleY = Math.max(0.08, scaleYValue); if (scaleYValue < 0.08 && !ring.landed) { const tempFlatThickness = GROUND_FLAT_RING_THICKNESS * 0.8; const halfFlatViewThickness = tempFlatThickness / 2; const flatDrawWidth = outerRadius * 2; ctx.fillStyle = RING_OUTLINE_COLOR; ctx.fillRect( -flatDrawWidth / 2 - RING_OUTLINE_WIDTH_ON_SCREEN, -halfFlatViewThickness - RING_OUTLINE_WIDTH_ON_SCREEN, flatDrawWidth + (RING_OUTLINE_WIDTH_ON_SCREEN * 2), tempFlatThickness + (RING_OUTLINE_WIDTH_ON_SCREEN * 2) ); ctx.fillStyle = ring.color; ctx.fillRect( -flatDrawWidth / 2, -halfFlatViewThickness, flatDrawWidth, tempFlatThickness ); } else { ctx.scale(1, effectiveScaleY); const outlineScaledOffset = RING_OUTLINE_WIDTH_ON_SCREEN / effectiveScaleY; ctx.beginPath(); ctx.arc(0, 0, outerRadius + outlineScaledOffset, 0, Math.PI * 2, false); ctx.arc(0, 0, Math.max(0, innerRadiusMaterial - outlineScaledOffset), 0, Math.PI * 2, true); ctx.fillStyle = RING_OUTLINE_COLOR; ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, outerRadius, 0, Math.PI * 2, false); ctx.arc(0, 0, innerRadiusMaterial, 0, Math.PI * 2, true);    ctx.fillStyle = ring.color; ctx.fill(); } } ctx.restore(); }
    function drawAllPegsAndLandedRings() { if(!pegs) return; pegs.forEach(peg => { ctx.fillStyle = PEG_FILL_COLOR; ctx.strokeStyle = PEG_STROKE_COLOR; ctx.lineWidth = 2; const pegTopY = peg.bottomY - peg.height; ctx.beginPath(); ctx.roundRect(peg.x - PEG_VISUAL_WIDTH / 2, pegTopY, PEG_VISUAL_WIDTH, peg.height, [PEG_VISUAL_WIDTH/3, PEG_VISUAL_WIDTH/3, 0, 0]); ctx.fill(); ctx.stroke(); peg.landedRings.forEach(drawRing); }); }
    function drawArcadeInfoOnCanvas() { if (currentGameMode !== 'arcade' || !gameRunning || gameOver || currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length) return; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; if(!levelConfig) return; ctx.save(); ctx.font = 'bold 18px Arial'; ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; ctx.shadowBlur = 2; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1; ctx.fillText(`Nivel: ${currentArcadeLevel + 1}`, 10, 10); const minutes = Math.floor(timeLeftInLevel / 60); const seconds = Math.floor(timeLeftInLevel % 60); ctx.fillText(`Tiempo: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`, 10, 35); let currentTotalLandedRingsInPegs = 0; if(pegs) pegs.forEach(p => currentTotalLandedRingsInPegs += p.landedRings.length); let objectiveDisplay = ""; if(levelConfig.ringsObjective.type === 'fillPegs'){ objectiveDisplay = `Llenar ${levelConfig.ringsObjective.count} palos`; } if(levelConfig.OR_ringsObjective && levelConfig.OR_ringsObjective.type === 'minPerPeg'){ objectiveDisplay += (objectiveDisplay ? " O " : "") + `${levelConfig.OR_ringsObjective.count} aros/palo`; } ctx.fillText(`Aros: ${currentTotalLandedRingsInPegs} (Obj: ${objectiveDisplay.includes("Llenar") ? levelConfig.ringsObjective.count + " palos" : levelConfig.OR_ringsObjective.count + "/palo"})`, 10, 60); ctx.restore(); }
    function drawScoreOnCanvas() { if (startScreen && startScreen.style.display === 'flex' && !gameRunning) return; if (gameOver && currentGameMode === 'arcade' && (currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length )) return; ctx.save(); ctx.font = `bold ${currentScoreDisplaySize}px Arial`; ctx.textAlign = 'right'; ctx.textBaseline = 'top'; ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; ctx.shadowBlur = 3; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1; if (scorePulseActive) { ctx.fillStyle = '#FFD700'; } else { ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; } ctx.fillText(`Score: ${score}`, gameScreenWidth - 10, 10); ctx.restore(); }
    instructionTimeout = null; function showMessage(text, duration = 3000, isInstruction = false) { if (instructionTimeout && !isInstruction) { clearTimeout(instructionTimeout); } if(messageBoard) {messageBoard.textContent = text; messageBoard.style.opacity = 1;} if (!isInstruction) { instructionTimeout = setTimeout(() => { if(messageBoard) messageBoard.style.opacity = 0; instructionTimeout = null; setTimeout(setPersistentInstructions, 700); }, duration); } }
    function setPersistentInstructions() { console.log(">>>> setPersistentInstructions llamada. sensorActive:", sensorActive, "sensorAvailable:", sensorAvailable); if (!messageBoard) { return;} if (messageBoard.style.display === 'none' && !isInstruction) { /* No hacer nada si está oculto Y no es una instrucción crucial */ return; } let instructionMessage = "PC: Flechas=Inclinar, A/D=Jets."; if (sensorAvailable) { if (sensorActive) { instructionMessage = "Móvil: Sensor ACTIVO. ¡Inclina tu dispositivo!"; } else { instructionMessage = "PC: Flechas=Inclinar, A/D=Jets. Móvil: Botones/Activar SENSOR."; } } else { instructionMessage = "PC: Flechas=Inclinar, A/D=Jets. Móvil: Botones TILT (Sensor no disp.)"; } messageBoard.textContent = instructionMessage; messageBoard.style.opacity = 1; /* messageBoard.style.display = 'block'; // Dejamos que el setup inicial controle esto */ console.log(">>>> messageBoard actualizado:", instructionMessage);  }
    function updateScore(pointsToAdd, message = "") { if (pointsToAdd > 0) { score += pointsToAdd; scorePulseActive = true; scorePulseTimer = SCORE_PULSE_DURATION; currentScoreDisplaySize = SCORE_PULSE_SIZE; } else if (pointsToAdd < 0) { score += pointsToAdd; } if (message && message !== "") { showMessage(message, 2500); } }
    function checkArcadeLevelWinCondition() { if (currentGameMode !== 'arcade' || currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length || !pegs) return false; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; let fullPegsCount = 0; pegs.forEach(peg => { if (peg.landedRings.length >= MAX_RINGS_PER_PEG) { fullPegsCount++; } }); if (levelConfig.ringsObjective.type === 'fillPegs' && fullPegsCount >= levelConfig.ringsObjective.count) { return true; } if (levelConfig.OR_ringsObjective && levelConfig.OR_ringsObjective.type === 'minPerPeg') { const minRings = levelConfig.OR_ringsObjective.count; let allPegsMeetMin = true; for (const peg of pegs) { if (peg.landedRings.length < minRings) { allPegsMeetMin = false; break; } } if (allPegsMeetMin) return true; } return false; }
    function checkAndApplyBonuses(landedRing, peg) { let pointsForThisSpecificRing = landedRing.basePoints; let bonusMessageText = ""; baseScoreFromRings += landedRing.basePoints; if ('vibrate' in navigator) { navigator.vibrate(75); } let mightBecomeMonoColor = true; if(peg.landedRings.length === MAX_RINGS_PER_PEG) { const firstColorInPeg = peg.landedRings[0].color; for(const r of peg.landedRings) { if (r.color !== firstColorInPeg) { mightBecomeMonoColor = false; break; } } } else { mightBecomeMonoColor = false; } if (peg.landedRings.length > 1 && !mightBecomeMonoColor && landedRing.landedOrder > 0 ) { const previousRingInStack = peg.landedRings[landedRing.landedOrder -1]; if (previousRingInStack && previousRingInStack.color === landedRing.color) { let colorStreakBonus = landedRing.basePoints; pointsForThisSpecificRing += colorStreakBonus; bonusScoreFromColorStreak += colorStreakBonus; bonusMessageText += ` Color x2!`;} } landedRing.awardedPoints = pointsForThisSpecificRing; createFloatingScore(landedRing.x, landedRing.finalYonPeg - RING_OUTER_RADIUS, `+${pointsForThisSpecificRing}${bonusMessageText}`, landedRing.color); updateScore(pointsForThisSpecificRing); if (currentGameMode === 'normal') { landedRingsCount++; } if (peg.landedRings.length === MAX_RINGS_PER_PEG && !peg.isFullAndScored) { peg.isFullAndScored = true; let isCurrentPegMonoColor = true; const firstLandedColor = peg.landedRings[0].color; for (let k = 1; k < MAX_RINGS_PER_PEG; k++) { if (peg.landedRings[k].color !== firstLandedColor) { isCurrentPegMonoColor = false; break; } } let additionalBonusScore = 0; let pegCompletionMessage = ""; if (isCurrentPegMonoColor) { peg.isMonoColor = true; peg.monoColorValue = firstLandedColor; let currentPegAwardedPointsSum = 0; peg.landedRings.forEach(r => currentPegAwardedPointsSum += r.awardedPoints); let targetMonoScore = (landedRing.basePoints * MAX_RINGS_PER_PEG) * 10; additionalBonusScore = targetMonoScore - currentPegAwardedPointsSum; if(additionalBonusScore < 0) additionalBonusScore = 0; bonusScoreFromMonoColorPegsSpecific += additionalBonusScore; pegCompletionMessage = `PALO MONOCOLOR! (x10)`; } else { let pegTotalAwardedPoints = 0; peg.landedRings.forEach(r => { pegTotalAwardedPoints += r.awardedPoints; }); additionalBonusScore = pegTotalAwardedPoints * 3; bonusScoreFromFullPegsGeneral += additionalBonusScore; pegCompletionMessage = `PALO LLENO! (x4)`; } if(additionalBonusScore > 0) updateScore(additionalBonusScore, pegCompletionMessage); if (currentGameMode === 'normal') checkAllPegsCompleted_NormalMode(); } if (currentGameMode === 'arcade' && !gameOver) { if (checkArcadeLevelWinCondition()) { goToNextArcadeLevel(); } } }
    function checkAllPegsCompleted_NormalMode() { if (currentGameMode !== 'normal') return; if (allPegsCompletedBonusFactor > 1 && masterBonusFactor > 1) return; if(!pegs) return; const allPegsNowFull = pegs.every(p => p.isFullAndScored); if (allPegsNowFull && allPegsCompletedBonusFactor === 1) { allPegsCompletedBonusFactor = 2; showMessage("TODOS LOS PALOS LLENOS! Puntos x2!", 3500, true); let monoColorPegCount = 0; const usedColorsForMaster = new Set(); pegs.forEach(p => { if (p.isMonoColor) { monoColorPegCount++; usedColorsForMaster.add(p.monoColorValue); } }); if (monoColorPegCount === TOTAL_COLORS && usedColorsForMaster.size === TOTAL_COLORS) { masterBonusFactor = 100; showMessage("¡¡BONO MAESTRO!! Puntuación Final x100!", 5000, true); } triggerGameOver_NormalMode(); } }
    function goToNextArcadeLevel() { if (gameOver || isPausedForLevelTransition || currentArcadeLevel < 0 || currentArcadeLevel >= ARCADE_LEVELS.length) return; console.log("goToNextArcadeLevel llamado. Nivel actual completado:", currentArcadeLevel + 1); isPausedForLevelTransition = true; gameRunning = false; if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null; const levelConfig = ARCADE_LEVELS[currentArcadeLevel]; const timeBonus = Math.floor(timeLeftInLevel * levelConfig.bonusPerSecond); const currentLevelEndScreen = document.getElementById('levelEndScreen'); const currentLevelEndTitle = document.getElementById('levelEndTitle'); const currentLevelEndTimeBonus = document.getElementById('levelEndTimeBonus'); const currentLevelEndTotalScore = document.getElementById('levelEndTotalScore'); const currentNextLevelButton = document.getElementById('nextLevelButton'); const currentArcadeEndToMenuButton = document.getElementById('arcadeEndToMenuButton'); if (!currentLevelEndScreen || !currentLevelEndTitle || !currentLevelEndTimeBonus || !currentLevelEndTotalScore || !currentNextLevelButton || !currentArcadeEndToMenuButton) {console.error("goToNextArcadeLevel: Faltan elementos del modal de fin de nivel."); return;} if (currentLevelEndTitle) currentLevelEndTitle.textContent = `¡${levelConfig.name || ('Nivel '+(currentArcadeLevel+1))} Superado!`; let objectiveText = ""; if (timeBonus > 0) { updateScore(timeBonus); objectiveText = `Bonus por Tiempo: +${timeBonus} pts`; } else { objectiveText = "¡Justo a tiempo!"; } if (currentLevelEndTimeBonus) {currentLevelEndTimeBonus.textContent = objectiveText; currentLevelEndTimeBonus.style.display = 'block'; } if (currentLevelEndTotalScore) currentLevelEndTotalScore.textContent = `Puntuación Total Arcade: ${score}`; currentArcadeLevel++; if (currentArcadeLevel >= ARCADE_LEVELS.length) { if(currentNextLevelButton) currentNextLevelButton.style.display = 'none'; if(currentArcadeEndToMenuButton) currentArcadeEndToMenuButton.textContent = "¡Increíble! Volver al Menú"; if (currentLevelEndTitle) currentLevelEndTitle.textContent = "¡MODO ARCADE COMPLETADO!"; } else { if(currentNextLevelButton) currentNextLevelButton.style.display = 'inline-block'; if(currentNextLevelButton) currentNextLevelButton.textContent = `Ir al Nivel ${currentArcadeLevel + 1}`; if(currentArcadeEndToMenuButton) currentArcadeEndToMenuButton.textContent = "Salir al Menú"; } if(currentLevelEndScreen) currentLevelEndScreen.style.display = 'flex'; if (!gameLoopId) gameLoopId = requestAnimationFrame(gameLoop); }
    function triggerGameOver_NormalMode() { if (gameOver) return; gameOver = true; gameRunning = false; let finalScoreCalculation = baseScoreFromRings + bonusScoreFromColorStreak + bonusScoreFromFullPegsGeneral + bonusScoreFromMonoColorPegsSpecific; if(allPegsCompletedBonusFactor > 1) { finalScoreCalculation *= allPegsCompletedBonusFactor; } if(masterBonusFactor > 1) { let scoreBeforeAnyFinalMultiplier = baseScoreFromRings + bonusScoreFromColorStreak + bonusScoreFromFullPegsGeneral + bonusScoreFromMonoColorPegsSpecific; finalScoreCalculation = scoreBeforeAnyFinalMultiplier * masterBonusFactor; } score = Math.round(finalScoreCalculation); if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } showEndGameScreen(currentGameMode); }
    function triggerGameOver_ArcadeMode(allLevelsCompleted = false) { if (gameOver) return; gameOver = true; gameRunning = false; if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } showEndGameScreen(currentGameMode, allLevelsCompleted, currentArcadeLevel); }
    function showEndGameScreen(mode, arcadeWon = false, levelReachedIfLost = 0) { const existingScreen = document.getElementById('endGameScreen'); if (existingScreen) existingScreen.parentNode.removeChild(existingScreen); const screenDOM = document.createElement('div'); screenDOM.id = 'endGameScreen'; screenDOM.classList.add('visible'); let summaryHTML = ``; if (mode === 'normal') { summaryHTML = `<h2>¡Juego Terminado!</h2><p>Puntos Base Aros: ${baseScoreFromRings}</p>`; if (bonusScoreFromColorStreak > 0) summaryHTML += `<p>Bono Racha Color: +${bonusScoreFromColorStreak}</p>`; if (bonusScoreFromFullPegsGeneral > 0) summaryHTML += `<p>Bono Palos Llenos (Normal): +${bonusScoreFromFullPegsGeneral}</p>`; if (bonusScoreFromMonoColorPegsSpecific > 0) summaryHTML += `<p>Bono Palos Monocolor: +${bonusScoreFromMonoColorPegsSpecific}</p>`; let subTotalBeforeMultipliers = baseScoreFromRings + bonusScoreFromColorStreak + bonusScoreFromFullPegsGeneral + bonusScoreFromMonoColorPegsSpecific; if (masterBonusFactor > 1) { summaryHTML += `<p style="color: gold; font-weight: bold;">¡BONO MAESTRO!: x${masterBonusFactor} (sobre ${subTotalBeforeMultipliers})</p>`; } else if (allPegsCompletedBonusFactor > 1) { summaryHTML += `<p style="color: lightblue;">Bono Todos Palos Llenos: x${allPegsCompletedBonusFactor} (sobre ${subTotalBeforeMultipliers})</p>`; } summaryHTML += `<h3 style="margin-top: 20px; color: #FFD700;">PUNTUACIÓN FINAL: ${score}</h3>`; } else if (mode === 'arcade') { if (arcadeWon) { summaryHTML = `<h2>¡MODO ARCADE COMPLETADO!</h2><p>¡Has superado todos los niveles!</p>`; } else { summaryHTML = `<h2>¡TIEMPO AGOTADO!</h2><p>Nivel Alcanzado: ${levelReachedIfLost + 1}</p>`; } summaryHTML += `<h3 style="margin-top: 20px; color: #FFD700;">PUNTUACIÓN ARCADE: ${score}</h3>`; } const playAgainButton = document.createElement('button'); playAgainButton.textContent = 'Volver al Inicio'; playAgainButton.onclick = () => { hideEndGameScreen(); if(startScreen) startScreen.style.display = 'flex'; if(howToPlayButton) howToPlayButton.style.display = 'inline-block'; gameRunning = false; score = 0; currentArcadeLevel = 0; timeLeftInLevel = 0; currentScoreDisplaySize = SCORE_NORMAL_SIZE; currentGameMode = 'none'; if (enableSensorButton && sensorAvailable) { enableSensorButton.style.display = 'inline-block'; enableSensorButton.disabled = false; enableSensorButton.textContent = "SENSOR";} if (tiltLeftButton) tiltLeftButton.style.display = 'flex'; if(tiltRightButton) tiltRightButton.style.display = 'flex'; sensorActive = false; setPersistentInstructions(); if (!gameLoopId) { if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } gameLoopId = requestAnimationFrame(gameLoop); } }; screenDOM.innerHTML = summaryHTML; screenDOM.appendChild(playAgainButton); if(document.body) document.body.appendChild(screenDOM); };
    function hideEndGameScreen() { const screenDOM = document.getElementById('endGameScreen'); if (screenDOM) { screenDOM.classList.remove('visible'); setTimeout(() => { if (screenDOM && screenDOM.parentNode) { screenDOM.parentNode.removeChild(screenDOM); } }, 500); } };
    function hexToRgb(hex) { let r = 0, g = 0, b = 0; if (!hex || typeof hex !== 'string') return { r: 255, g: 255, b: 255 }; if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; } else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; } else { return { r: 255, g: 255, b: 255 }; } return { r: +r, g: +g, b: +b }; };
    function createFloatingScore(x, y, text, color = "#FFFFFF", durationFrames = 90, upwardSpeed = 0.8) { floatingScores.push({ x: x, y: y, text: text, color: color, opacity: 1, vy: -upwardSpeed, life: durationFrames, initialLife: durationFrames, currentFontSize: 20, maxFontSize: 30 }); };
    function updateAndDrawFloatingScores(dt) { const accelerationFactor = dt * TARGET_FPS; ctx.save(); ctx.textAlign = "center"; ctx.shadowColor = "rgba(0,0,0,0.6)"; ctx.shadowBlur = 4; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; for (let i = floatingScores.length - 1; i >= 0; i--) { const fs = floatingScores[i]; fs.y += fs.vy * accelerationFactor; fs.life -= accelerationFactor; const progress = 1 - (fs.life / fs.initialLife); fs.currentFontSize = 20 + (fs.maxFontSize - 20) * Math.sin(progress * Math.PI * 0.8); if(fs.currentFontSize < 18) fs.currentFontSize = 18; fs.opacity = (fs.life / fs.initialLife); if (fs.opacity < 0) fs.opacity = 0; if (fs.life <= 0) { floatingScores.splice(i, 1); } else { ctx.font = `bold ${Math.round(fs.currentFontSize)}px Arial`; const rgb = hexToRgb(fs.color); ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${fs.opacity})`; ctx.fillText(fs.text, fs.x, fs.y); } } ctx.restore(); };
    function createJetParticle(xSide, strength) { if (jetParticles.length >= MAX_JET_PARTICLES) { return; } const isLeft = xSide === -1; const particleOriginX = isLeft ? gameScreenWidth * 0.22 : gameScreenWidth * 0.78; const particle = { x: particleOriginX + (Math.random() - 0.5) * 15, y: gameScreenHeight - 25 - Math.random() * 10, vx: (Math.random() - 0.5) * 2 + (isLeft ? 0.8 : -0.8) * (strength*2.5), vy: -(3.5 + Math.random() * 3.5 + strength * 5.5), radius: 2.0 + Math.random() * 2.0 + strength * 3.0, opacity: 0.45 + strength * 0.5, life: 30 + Math.random() * 25 + strength * 30, color: `rgba(220, 240, 255, ${0.25 + Math.random() * 0.3})` }; jetParticles.push(particle); };
    function updateAndDrawJetParticles(dt) { const accelerationFactor = dt * TARGET_FPS; ctx.save(); for (let i = jetParticles.length - 1; i >= 0; i--) { const p = jetParticles[i]; p.x += p.vx * accelerationFactor; p.y += p.vy * accelerationFactor; p.vy += GRAVITY_BASE * 0.2 * accelerationFactor; p.life -= accelerationFactor; const baseOpacityMatch = p.color.match(/rgba\([\d\s,]+([\d.]+)\)/); const baseOpacity = baseOpacityMatch ? parseFloat(baseOpacityMatch[1]) : 0.3; p.opacity = baseOpacity * (p.life / (30 + 25 + 30)); if (p.opacity < 0) p.opacity = 0; p.radius *= (1 - 0.020 * accelerationFactor); if (p.opacity <= 0 || p.radius <= 0.4 || p.life <= 0 || p.y < -p.radius || p.y > gameScreenHeight + p.radius) { jetParticles.splice(i, 1); } else { ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); const colorParts = p.color.substring(p.color.indexOf('(') + 1, p.color.lastIndexOf(',')).trim(); ctx.fillStyle = `rgba(${colorParts}, ${p.opacity.toFixed(2)})`; ctx.fill(); } } ctx.restore(); };
    function updateRings(actualTiltForceToApply, dt) { const accelerationFactor = dt * TARGET_FPS; rings.forEach(ring => { if (ring.landed && !ring.isSlidingOnPeg) { ring.isFlat = true; ring.rotationAngle = Math.PI / 2; ring.rotationSpeed = 0; ring.zRotationAngle = 0; ring.zRotationSpeed = 0; ring.vx = 0; ring.vy = 0; return; } if (ring.isSlidingOnPeg) { const slideSpeedValue = 4.0 * accelerationFactor; if (ring.y < ring.finalYonPeg) { ring.y += slideSpeedValue; if (ring.y >= ring.finalYonPeg) { ring.y = ring.finalYonPeg; ring.isSlidingOnPeg = false; ring.vy = 0; /* landedRingsCount se actualiza en checkAndApplyBonuses solo para modo normal ahora */ } } else { ring.y -= slideSpeedValue; if (ring.y <= ring.finalYonPeg) { ring.y = ring.finalYonPeg; ring.isSlidingOnPeg = false; ring.vy = 0; /* landedRingsCount se actualiza en checkAndApplyBonuses solo para modo normal ahora */ } } ring.isFlat = true; ring.rotationAngle = Math.PI / 2; ring.rotationSpeed = 0; ring.zRotationAngle = 0; ring.zRotationSpeed = 0; ring.vx = 0; return; } ring.vy += GRAVITY_BASE * accelerationFactor; const frictionRate = 1 - WATER_FRICTION_COEFF; ring.vx *= Math.pow(frictionRate, accelerationFactor); ring.vy *= Math.pow(frictionRate, accelerationFactor); let forceAppliedToRingThisFrame = false; [[leftJetPressure, 0.22, 1], [rightJetPressure, 0.78, -1]].forEach(([pressure, jetXFactor, horizontalDir]) => { if (pressure > 0.01) { let currentJetForceVertical = BASE_JET_STRENGTH * pressure; let currentJetForceHorizontal = JET_HORIZONTAL_INFLUENCE_RATIO * currentJetForceVertical; let jetSourceX = gameScreenWidth * jetXFactor; const distanceX = ring.x - jetSourceX; let proximityFactorY = 0; const yPosInJetEffect = (ring.y - (gameScreenHeight - JET_EFFECT_RADIUS_Y)); if (yPosInJetEffect > 0 && ring.y < gameScreenHeight) { proximityFactorY = 1 - Math.pow( (JET_EFFECT_RADIUS_Y - yPosInJetEffect) / JET_EFFECT_RADIUS_Y, JET_VERTICAL_FALLOFF_POWER); proximityFactorY = Math.max(0.05, Math.min(1, proximityFactorY)); } if (Math.abs(distanceX) < JET_EFFECT_RADIUS_X && proximityFactorY > 0.01) { const proximityFactorX = 1 - (Math.abs(distanceX) / JET_EFFECT_RADIUS_X); const totalProximityFactor = proximityFactorX * proximityFactorY; if (totalProximityFactor > 0) { ring.vy -= (currentJetForceVertical * totalProximityFactor) * accelerationFactor; ring.vx += (currentJetForceHorizontal * totalProximityFactor * horizontalDir) * accelerationFactor; forceAppliedToRingThisFrame = true; } } } }); if (actualTiltForceToApply !== 0) { ring.vx += actualTiltForceToApply * accelerationFactor; forceAppliedToRingThisFrame = true; } const isOnGroundAndEffectivelySlow = ring.y + RING_OUTER_RADIUS >= gameScreenHeight - (GROUND_FLAT_RING_THICKNESS / 2 + RING_OUTLINE_WIDTH_ON_SCREEN + 1) && Math.abs(ring.vy) < 0.15 && Math.abs(ring.vx) < 0.15; if (ring.isFlat && forceAppliedToRingThisFrame && !isOnGroundAndEffectivelySlow) { ring.isFlat = false; if (ring.rotationSpeed === 0) { ring.rotationSpeed = ring.initialRotationSpeed * (Math.random() < 0.5 ? 0.7 : -0.7) * (0.7 + Math.random() * 0.6) ; } if (ring.zRotationSpeed === 0 && forceAppliedToRingThisFrame) { ring.zRotationSpeed = (Math.random() - 0.5) * 0.03; } } else if (!ring.landed && isOnGroundAndEffectivelySlow && !forceAppliedToRingThisFrame) { ring.isFlat = true; ring.zRotationSpeed = 0; } if (!ring.isFlat) { ring.rotationAngle += ring.rotationSpeed * accelerationFactor; if (ring.rotationAngle > Math.PI * 2) ring.rotationAngle -= Math.PI * 2; if (ring.rotationAngle < 0) ring.rotationAngle += Math.PI * 2; const rotationalFrictionRate = 1 - 0.01; ring.rotationSpeed *= Math.pow(rotationalFrictionRate, accelerationFactor); if (Math.abs(ring.rotationSpeed) < 0.005 / (accelerationFactor > 0 ? accelerationFactor : 1) ) ring.rotationSpeed = 0; } else { ring.rotationAngle = Math.PI / 2; ring.rotationSpeed = 0; } ring.zRotationAngle += ring.zRotationSpeed * accelerationFactor; if (ring.zRotationAngle > Math.PI * 2) ring.zRotationAngle -= Math.PI * 2; else if (ring.zRotationAngle < 0) ring.zRotationAngle += Math.PI * 2; ring.zRotationSpeed *= Math.pow((1 - 0.025), accelerationFactor); if (Math.abs(ring.zRotationSpeed) < 0.001 / (accelerationFactor || 1)) ring.zRotationSpeed = 0; });
    for (let iter = 0; iter < 3; iter++) { for (let i = 0; i < rings.length; i++) { const ring1 = rings[i]; if (ring1.landed) continue; for (let j = i + 1; j < rings.length; j++) { const ring2 = rings[j]; if (ring2.landed) continue; const dx = ring2.x - ring1.x; const dy = ring2.y - ring1.y; const distance = Math.sqrt(dx * dx + dy * dy); const minDistance = RING_OUTER_RADIUS * 2; if (distance < minDistance && distance > 0.001) { const overlap = (minDistance - distance); const normalX = dx / distance; const normalY = dy / distance; ring1.x -= overlap * 0.5 * normalX; ring1.y -= overlap * 0.5 * normalY; ring2.x += overlap * 0.5 * normalX; ring2.y += overlap * 0.5 * normalY; const relativeVx = ring1.vx - ring2.vx; const relativeVy = ring1.vy - ring2.vy; const dotProduct = relativeVx * normalX + relativeVy * normalY; if (dotProduct > 0) { const impulse = (-(1 + RING_COLLISION_BOUNCE) * dotProduct) / 2; ring1.vx += impulse * normalX; ring1.vy += impulse * normalY; ring2.vx -= impulse * normalX; ring2.vy -= impulse * normalY; if (!ring1.isFlat && Math.abs(ring1.rotationSpeed) < 0.2) ring1.rotationSpeed += (Math.random() - 0.5) * 0.05 / (accelerationFactor || 1); if (!ring2.isFlat && Math.abs(ring2.rotationSpeed) < 0.2) ring2.rotationSpeed += (Math.random() - 0.5) * 0.05 / (accelerationFactor || 1); if (Math.abs(ring1.zRotationSpeed) < 0.05) ring1.zRotationSpeed += (Math.random() - 0.5) * 0.03 / (accelerationFactor || 1); if (Math.abs(ring2.zRotationSpeed) < 0.05) ring2.zRotationSpeed += (Math.random() - 0.5) * 0.03 / (accelerationFactor || 1); } } } } }
    rings.forEach((ring, index) => { if (ring.landed && !ring.isSlidingOnPeg) return; if (ring.isSlidingOnPeg) return; let prevX = ring.x; let prevY = ring.y; ring.x += ring.vx * accelerationFactor; ring.y += ring.vy * accelerationFactor; let interactionOccurredThisFrame = false; if (!ring.landed && pegs) { for (const peg of pegs) { if (ring.landed || interactionOccurredThisFrame || peg.landedRings.length >= MAX_RINGS_PER_PEG || (currentGameMode === 'normal' && peg.isFullAndScored) ) { continue; } const pegCenterX = peg.x; const pegTop = peg.bottomY - peg.height; const ringRadius = RING_OUTER_RADIUS; const landingCatchWidth = PEG_VISUAL_WIDTH * 2.0; const horizontallyAligned = Math.abs(ring.x - pegCenterX) < landingCatchWidth / 2; const isFalling = ring.vy > 0; const ringBottom = ring.y + ringRadius; const prevRingBottom = prevY + ringRadius; if (isFalling && horizontallyAligned && ringBottom >= pegTop && prevRingBottom < pegTop + RING_VISUAL_THICKNESS * 0.8 ) { const targetLandedY = (peg.bottomY - FLAT_RING_VIEW_THICKNESS / 2) - (peg.landedRings.length * FLAT_RING_VIEW_THICKNESS); ring.isSlidingOnPeg = true; ring.finalYonPeg = targetLandedY; ring.landed = true; ring.isFlat = true; ring.pegIndex = peg.id; ring.x = pegCenterX; if (ring.y < targetLandedY) { ring.vy = Math.min(4.0, 2.0 + peg.landedRings.length * 0.1); } else { ring.vy = -Math.min(4.0, 2.0 + peg.landedRings.length * 0.1); if(targetLandedY > ring.y - 1) ring.vy = 0.1; } ring.vx = 0; ring.rotationSpeed = 0; ring.rotationAngle = Math.PI / 2; ring.zRotationAngle = 0; ring.zRotationSpeed = 0; ring.landedOrder = peg.landedRings.length; peg.landedRings.push(ring); checkAndApplyBonuses(ring, peg); interactionOccurredThisFrame = true; break; } if (!ring.landed && !interactionOccurredThisFrame) { const pegBodyLeft = pegCenterX - (PEG_VISUAL_WIDTH * 1.0) / 2; const pegBodyRight = pegCenterX + (PEG_VISUAL_WIDTH * 1.0) / 2; if (ring.y + ringRadius > pegTop + RING_VISUAL_THICKNESS * 0.5 && ring.y - ringRadius < peg.bottomY) { if (ring.x + ringRadius > pegBodyLeft && prevX + ringRadius <= pegBodyLeft + 1 && ring.vx > 0) { ring.x = pegBodyLeft - ringRadius - 0.1; ring.vx *= PEG_COLLISION_BOUNCE_FACTOR; interactionOccurredThisFrame = true; } else if (ring.x - ringRadius < pegBodyRight && prevX - ringRadius >= pegBodyRight -1 && ring.vx < 0) { ring.x = pegBodyRight + ringRadius + 0.1; ring.vx *= PEG_COLLISION_BOUNCE_FACTOR; interactionOccurredThisFrame = true; } } if (!interactionOccurredThisFrame && isFalling && ring.y + ringRadius > pegTop && prevY + ringRadius <= pegTop + 3 && Math.abs(ring.x - pegCenterX) < (PEG_VISUAL_WIDTH / 2 + ringRadius)) { ring.y = pegTop - ringRadius - 0.1; ring.vy *= (PEG_COLLISION_BOUNCE_FACTOR - 0.1); ring.vx += (Math.random() - 0.5) * 0.3 * accelerationFactor; interactionOccurredThisFrame = true;} } if (interactionOccurredThisFrame) break; } } if (ring.x - RING_OUTER_RADIUS < 0) { ring.x = RING_OUTER_RADIUS; ring.vx *= BOUNCE_FACTOR; } if (ring.x + RING_OUTER_RADIUS > gameScreenWidth) { ring.x = gameScreenWidth - RING_OUTER_RADIUS; ring.vx *= BOUNCE_FACTOR; } if (ring.y - RING_OUTER_RADIUS < 0) { ring.y = RING_OUTER_RADIUS; ring.vy *= BOUNCE_FACTOR;} const effectiveRingBottomExtent = ring.y + (ring.isFlat ? GROUND_FLAT_RING_THICKNESS / 2 : RING_OUTER_RADIUS); const groundHitPosition = gameScreenHeight - RING_OUTLINE_WIDTH_ON_SCREEN; if (effectiveRingBottomExtent >= groundHitPosition) { ring.y = groundHitPosition - (ring.isFlat ? GROUND_FLAT_RING_THICKNESS / 2 : RING_OUTER_RADIUS); if (ring.vy > 0) ring.vy *= BOUNCE_FACTOR * 0.3; if (Math.abs(ring.vy) < 0.05 / (accelerationFactor > 0 ? accelerationFactor : 1) ) { ring.vy = 0; if (!ring.landed) { ring.isFlat = true; if (ring.rotationSpeed !==0) ring.rotationSpeed = 0; ring.rotationAngle = Math.PI / 2; if (ring.zRotationSpeed !== 0) ring.zRotationSpeed = 0;} } }
    }); };
    function handleOrientation(event) { let gamma = event.gamma; if (gamma === null || gamma === undefined) {return;} const MAX_EFFECTIVE_GAMMA_SENSOR = 30; sensorTiltX = gamma / MAX_EFFECTIVE_GAMMA_SENSOR; sensorTiltX = Math.max(-1, Math.min(1, sensorTiltX));}
    function requestSensorPermission() { console.log(">>>> requestSensorPermission llamada."); if(!enableSensorButton) { console.error("requestSensorPermission: enableSensorButton no existe."); return; } enableSensorButton.classList.add('sensor-button--activating'); setTimeout(() => { if(enableSensorButton) enableSensorButton.classList.remove('sensor-button--activating'); }, 300); if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') { console.log("Sensor: Usando DeviceOrientationEvent.requestPermission()"); DeviceOrientationEvent.requestPermission().then(permissionState => { console.log("Sensor: Estado del permiso:", permissionState); if (permissionState === 'granted') { window.addEventListener('deviceorientation', handleOrientation, true); sensorActive = true; console.log("Sensor: Permiso concedido. sensorActive AHORA ES TRUE"); if(enableSensorButton) enableSensorButton.style.display = 'none'; if(tiltLeftButton) tiltLeftButton.style.display = 'none'; if(tiltRightButton) tiltRightButton.style.display = 'none'; if (messageBoard) setPersistentInstructions(); } else { sensorActive = false; if (messageBoard) showMessage("Permiso del sensor denegado.", 3000, true); if(enableSensorButton) {enableSensorButton.textContent = "Sensor Denegado"; enableSensorButton.disabled = true;} console.warn("Sensor: Permiso denegado. sensorActive AHORA ES FALSE"); if (messageBoard) setPersistentInstructions(); } }).catch(error => { sensorActive = false; console.error("Sensor: Error al solicitar permiso:", error); if (messageBoard) showMessage("Error al activar sensor.", 3000, true); if (messageBoard) setPersistentInstructions(); }); } else if (window.DeviceOrientationEvent){ console.log("Sensor: Navegador soporta DeviceOrientationEvent directamente."); window.addEventListener('deviceorientation', handleOrientation, true); sensorActive = true; console.log("Sensor: Listener añadido directamente. sensorActive AHORA ES TRUE"); if(enableSensorButton) enableSensorButton.style.display = 'none'; if(tiltLeftButton) tiltLeftButton.style.display = 'none'; if(tiltRightButton) tiltRightButton.style.display = 'none'; if (messageBoard) setPersistentInstructions(); } else { sensorAvailable = false; sensorActive = false; console.warn("Sensor: DeviceOrientationEvent no soportado."); if (messageBoard) showMessage("Sensor no soportado.", 3000, true); if(enableSensorButton) enableSensorButton.style.display = 'none'; if (messageBoard) setPersistentInstructions(); } }

    if (startGameButton) { startGameButton.addEventListener('click', () => { console.error("startGameButton (obsoleto?) presionado."); }); } // Mantener por si acaso, aunque ahora se usa startNormalModeButton

    // --- EVENT LISTENERS ---
    if (leftJetButton) { leftJetButton.addEventListener('mousedown', () => { leftJetInputActive = true; }); leftJetButton.addEventListener('mouseup', () => { leftJetInputActive = false; }); leftJetButton.addEventListener('mouseleave', () => { if(leftJetInputActive) {leftJetInputActive = false;} }); leftJetButton.addEventListener('touchstart', (e) => { e.preventDefault(); leftJetInputActive = true; }, { passive: false }); leftJetButton.addEventListener('touchend', (e) => { e.preventDefault(); leftJetInputActive = false; }); }
    if (rightJetButton) { rightJetButton.addEventListener('mousedown', () => { rightJetInputActive = true; }); rightJetButton.addEventListener('mouseup', () => { rightJetInputActive = false; }); rightJetButton.addEventListener('mouseleave', () => { if(rightJetInputActive) {rightJetInputActive = false;} }); rightJetButton.addEventListener('touchstart', (e) => { e.preventDefault(); rightJetInputActive = true; }, { passive: false }); rightJetButton.addEventListener('touchend', (e) => { e.preventDefault(); rightJetInputActive = false; }); }
    if (tiltLeftButton) { tiltLeftButton.addEventListener('mousedown', () => { tiltLeftActive = true; }); tiltLeftButton.addEventListener('mouseup', () => { tiltLeftActive = false; }); tiltLeftButton.addEventListener('mouseleave', () => { if (tiltLeftActive) { tiltLeftActive = false; } }); tiltLeftButton.addEventListener('touchstart', (e) => { e.preventDefault(); tiltLeftActive = true; }, { passive: false }); tiltLeftButton.addEventListener('touchend', (e) => { e.preventDefault(); tiltLeftActive = false; }); }
    if (tiltRightButton) { tiltRightButton.addEventListener('mousedown', () => { tiltRightActive = true; }); tiltRightButton.addEventListener('mouseup', () => { tiltRightActive = false; }); tiltRightButton.addEventListener('mouseleave', () => { if (tiltRightActive) { tiltRightActive = false; } }); tiltRightButton.addEventListener('touchstart', (e) => { e.preventDefault(); tiltRightActive = true;}, { passive: false }); tiltRightButton.addEventListener('touchend', (e) => { e.preventDefault(); tiltRightActive = false; });}
    if (resetButton) { resetButton.addEventListener('click', () => { console.log(">>>> resetButton clicked"); if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } gameRunning = false; gameOver = false; isPausedForLevelTransition = false; hideEndGameScreen(); if(levelStartScreen) levelStartScreen.style.display = 'none'; if(levelEndScreen) levelEndScreen.style.display = 'none'; if(startScreen) startScreen.style.display = 'flex'; else { console.error("Reset: startScreen not found!"); return;} if(howToPlayButton) howToPlayButton.style.display = 'inline-block'; if (enableSensorButton && sensorAvailable) { enableSensorButton.style.display = 'inline-block'; enableSensorButton.disabled = false; enableSensorButton.textContent = "SENSOR";} if (tiltLeftButton && (!sensorActive || !sensorAvailable) ) tiltLeftButton.style.display = 'flex'; if(tiltRightButton && (!sensorActive || !sensorAvailable) ) tiltRightButton.style.display = 'flex'; sensorActive = false; score = 0; currentScoreDisplaySize = SCORE_NORMAL_SIZE; currentArcadeLevel = 0; timeLeftInLevel = 0; currentGameMode = 'none'; if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); drawScoreOnCanvas(); setPersistentInstructions(); if (!gameLoopId) { if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } gameLoopId = requestAnimationFrame(gameLoop); }}); }
    if (fullscreenButton) { fullscreenButton.addEventListener('click', () => { const elem = document.querySelector('.game-container'); if (elem && !document.fullscreenElement) { if (elem.requestFullscreen) { elem.requestFullscreen(); } else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); } } else { if (document.exitFullscreen) { document.exitFullscreen(); } }}); }
    
    if (beginLevelButton) { beginLevelButton.addEventListener('click', () => { console.log(">>>> Begin Level Button Clicked"); startPreparedArcadeLevel(); }); } 
    else { console.error("ERROR: beginLevelButton NO ENCONTRADO para añadir listener."); }

    if (nextLevelButton) { nextLevelButton.addEventListener('click', () => { console.log(">>>> Next Level Button Clicked"); if(levelEndScreen) levelEndScreen.style.display = 'none'; if (currentArcadeLevel < ARCADE_LEVELS.length) { prepareArcadeLevel(currentArcadeLevel); } else { if(resetButton) resetButton.click(); } }); }
    else { console.error("ERROR: nextLevelButton NO ENCONTRADO para añadir listener."); }

    if (arcadeEndToMenuButton) { arcadeEndToMenuButton.addEventListener('click', () => { console.log(">>>> Arcade End To Menu Button Clicked"); if(levelEndScreen) levelEndScreen.style.display = 'none'; if(resetButton) resetButton.click(); }); }
    else { console.error("ERROR: arcadeEndToMenuButton NO ENCONTRADO para añadir listener."); }
    
    if (startNormalModeButton) { startNormalModeButton.addEventListener('click', () => { console.log(">>>> Start Normal Mode Button Clicked"); startGameFlow('normal'); }); }
    if (startArcadeModeButton) { startArcadeModeButton.addEventListener('click', () => { console.log(">>>> Start Arcade Mode Button Clicked"); startGameFlow('arcade'); }); }
    
    if (howToPlayButton) { howToPlayButton.addEventListener('click', () => { if(howToPlayScreen) howToPlayScreen.style.display = 'flex';}); }
    if (closeHowToPlayButton) { closeHowToPlayButton.addEventListener('click', () => { if(howToPlayScreen) howToPlayScreen.style.display = 'none';}); }
    window.addEventListener('click', (event) => { if (howToPlayScreen && event.target == howToPlayScreen) { howToPlayScreen.style.display = 'none'; }});
    window.addEventListener('keydown', (e) => { let keyProcessed = false; switch (e.code) { case KEY_LEFT_ARROW: tiltLeftActive = true; keyProcessed = true; break; case KEY_RIGHT_ARROW: tiltRightActive = true; keyProcessed = true; break; case KEY_JET_LEFT: leftJetInputActive = true; keyProcessed = true; break; case KEY_JET_RIGHT: rightJetInputActive = true; keyProcessed = true; break; } if (keyProcessed && (gameRunning || (startScreen && startScreen.style.display === 'none'))) e.preventDefault(); });
    window.addEventListener('keyup', (e) => { let keyProcessed = false; switch (e.code) { case KEY_LEFT_ARROW: tiltLeftActive = false; keyProcessed = true; break; case KEY_RIGHT_ARROW: tiltRightActive = false; keyProcessed = true; break; case KEY_JET_LEFT: leftJetInputActive = false; keyProcessed = true; break; case KEY_JET_RIGHT: rightJetInputActive = false; keyProcessed = true; break; } if (keyProcessed && (gameRunning || (startScreen && startScreen.style.display === 'none'))) e.preventDefault(); });
    
    if (enableSensorButton) { 
        if (window.DeviceOrientationEvent) { sensorAvailable = true; enableSensorButton.style.display = 'inline-block'; enableSensorButton.disabled = false; enableSensorButton.textContent = "SENSOR"; enableSensorButton.addEventListener('click', requestSensorPermission); } 
        else { sensorAvailable = false; enableSensorButton.style.display = 'none'; } 
    } else { sensorAvailable = false; }


    // --- GAME LOOP ---
    function gameLoop(currentTime) { 
        if (isPausedForLevelTransition) {
            const currentLSS = document.getElementById('levelStartScreen'); 
            const currentLES = document.getElementById('levelEndScreen');
            if ((currentLSS && currentLSS.style.display === 'flex') || (currentLES && currentLES.style.display === 'flex')) {
                 if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
                 drawScoreOnCanvas(); 
                 if(currentGameMode === 'arcade' && currentArcadeLevel >=0 && currentArcadeLevel < ARCADE_LEVELS.length && ARCADE_LEVELS[currentArcadeLevel] && currentLSS && currentLSS.style.display === 'flex') { 
                    drawArcadeInfoOnCanvas(); 
                }
            }
            // No cancelar y reiniciar aquí, la transición lo maneja o el usuario lo reanuda
            gameLoopId = requestAnimationFrame(gameLoop); 
            return;
        }
        if (!gameRunning && !gameOver) { 
            if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); }
            if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); 
            if (startScreen && (startScreen.style.display === 'none' || startScreen.style.display === '')) { drawScoreOnCanvas(); }
            gameLoopId = requestAnimationFrame(gameLoop); return;
        }
        if (gameOver) { return; }
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now(); let dt = (now - lastTime) / 1000.0; if (dt <= 0 || isNaN(dt) || dt > (TARGET_DT * 5) ) dt = TARGET_DT; lastTime = now; const deltaTime = dt; 
        if(ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (scorePulseActive) { scorePulseTimer -= deltaTime * TARGET_FPS; if (scorePulseTimer <= 0) { scorePulseActive = false; currentScoreDisplaySize = SCORE_NORMAL_SIZE; } else { const pulseProgress = 1 - (scorePulseTimer / SCORE_PULSE_DURATION); currentScoreDisplaySize = SCORE_NORMAL_SIZE + Math.sin(pulseProgress * Math.PI) * (SCORE_PULSE_SIZE - SCORE_NORMAL_SIZE); } }
        const accelerationFactor = deltaTime * TARGET_FPS; const pressureChange = JET_PRESSURE_INCREMENT_BASE * accelerationFactor; const pressureDecay = JET_PRESSURE_DECREMENT_BASE * accelerationFactor;
        if (leftJetInputActive) { leftJetPressure += pressureChange; if (leftJetPressure > MAX_JET_PRESSURE) leftJetPressure = MAX_JET_PRESSURE; if(leftJetPressure > 0.1) createJetParticle(-1, leftJetPressure); } else { leftJetPressure -= pressureDecay; if (leftJetPressure < 0) leftJetPressure = 0; }
        if (rightJetInputActive) { rightJetPressure += pressureChange; if (rightJetPressure > MAX_JET_PRESSURE) rightJetPressure = MAX_JET_PRESSURE; if(rightJetPressure > 0.1) createJetParticle(1, rightJetPressure); } else { rightJetPressure -= pressureDecay; if (rightJetPressure < 0) rightJetPressure = 0; }
        if (currentGameMode === 'arcade' && !gameOver && gameRunning) { timeLeftInLevel -= deltaTime; if (timeLeftInLevel <= 0) { timeLeftInLevel = 0; triggerGameOver_ArcadeMode(false); } }
        if (pegs && pegs.length > 0 && currentGameMode === 'arcade' && currentArcadeLevel >=0 && currentArcadeLevel < ARCADE_LEVELS.length && ARCADE_LEVELS[currentArcadeLevel] && (ARCADE_LEVELS[currentArcadeLevel].pegConfigKey === 'horizontalMovers' || ARCADE_LEVELS[currentArcadeLevel].pegConfigKey === 'verticalMovers')) { updatePegs(deltaTime); } 
        let forceForTiltUpdate = 0; if (sensorActive && sensorAvailable) { forceForTiltUpdate = sensorTiltX * TILT_FORCE_SENSOR_MULTIPLIER; if (forceForTiltUpdate > MAX_SENSOR_TILT_FORCE) forceForTiltUpdate = MAX_SENSOR_TILT_FORCE; if (forceForTiltUpdate < -MAX_SENSOR_TILT_FORCE) forceForTiltUpdate = -MAX_SENSOR_TILT_FORCE; /*if (Math.abs(forceForTiltUpdate)>0.001) console.log("Sensor Force:", forceForTiltUpdate.toFixed(3));*/ } else { if (tiltLeftActive === true && tiltRightActive === false) { forceForTiltUpdate = -TILT_FORCE_BUTTON_BASE; } else if (tiltRightActive === true && tiltLeftActive === false) { forceForTiltUpdate = TILT_FORCE_BUTTON_BASE; } }
        if(rings) updateRings(forceForTiltUpdate, deltaTime); 
        drawAllPegsAndLandedRings();
        if(rings) rings.forEach(ring => { drawRing(ring); });
        updateAndDrawJetParticles(deltaTime);
        updateAndDrawFloatingScores(deltaTime);
        drawScoreOnCanvas(); 
        if (currentGameMode === 'arcade' && !gameOver && gameRunning) drawArcadeInfoOnCanvas();
        else if (currentGameMode === 'normal' && landedRingsCount >= MAX_TOTAL_RINGS_ON_SCREEN && !gameOver) { checkAllPegsCompleted_NormalMode(); }
        if(gameRunning && !gameOver){ gameLoopId = requestAnimationFrame(gameLoop); }
    }
    
    function startGameFlow(mode) {
        console.log(">>>> startGameFlow llamada con modo:", mode);
        if(startScreen) startScreen.style.display = 'none'; 
        if (howToPlayScreen && howToPlayScreen.style.display !== 'none') howToPlayScreen.style.display = 'none'; 
        initGame(mode); 
        if (mode === 'arcade') { prepareArcadeLevel(0); } 
        else { gameRunning = true; gameOver = false; isPausedForLevelTransition = false; if (gameLoopId) { cancelAnimationFrame(gameLoopId); gameLoopId = null; } if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } else { lastTime = Date.now(); } gameLoopId = requestAnimationFrame(gameLoop); }
    }

    // --- Configuración Inicial Final ---
    if (messageBoard) { 
        messageBoard.style.display = 'block'; // Visible para debug sensor
        setPersistentInstructions(); 
    }
    if (startScreen) { startScreen.style.display = 'flex'; } 
    else { console.error("FATAL: startScreen NO ENCONTRADO. Pantalla de inicio no se puede mostrar."); }
    
    if (typeof performance !== 'undefined' && performance.now) { lastTime = performance.now(); } 
    else { lastTime = Date.now(); }
    gameLoopId = requestAnimationFrame(gameLoop); 
    console.log(">>>> Fin de initializeAndRunGame. UI loop inicializado.");
}

// --- LLAMADA A LA FUNCIÓN PRINCIPAL ---
initializeAndRunGame();
